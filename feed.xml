<?xml version='1.0' encoding='UTF-8'?>
<rss version='2.0' xmlns:atom='http://www.w3.org/2005/Atom'>
<channel>
<atom:link href='http://mneise.github.io' rel='self' type='application/rss+xml'/>
<generator>
clj-rss
</generator>
<title>
My Blog
</title>
<link>
http://mneise.github.io
</link>
<description>
Some updates and thoughts
</description>
<lastBuildDate>
Wed, 10 Jun 2015 19:59:33 -0500
</lastBuildDate>
<author>
Maria Neise
</author>
<item>
<guid>
http://mneise.github.io/posts/2015-06-08-week-2.html
</guid>
<link>
http://mneise.github.io/posts/2015-06-08-week-2.html
</link>
<title>
GSoC: Week 2
</title>
<description>
&lt;p&gt;&lt;em&gt;I have been accepted to this years Google's Summer of Code to work on ClojureScript. The goal of my project is to improve the integration of ClojureScript with the existing JavaScript ecosystem. I will post weekly updates about the progress of the project here. For more details about the project have a look at the ClojureScript GitHub &lt;a href='https://github.com/clojure/clojurescript/wiki/Google-Summer-of-Code-2015'&gt;wiki page&lt;/a&gt;.&lt;/em&gt;&lt;/p&gt;&lt;p&gt;During week 2 we continued to focus on adding support for CommonJS libraries to ClojureScript. An integral part of the CommonJS specification is the &lt;code&gt;require&lt;/code&gt; function. The &lt;code&gt;require&lt;/code&gt; function is used to import functionality that has been exported by other modules. In the following I will try to describe what we need to consider when adding support for CommonJS modules which depend on other modules and how a possible solution could look like.&lt;/p&gt;&lt;p&gt;Let's assume we have the following two CommonJS modules:&lt;/p&gt;&lt;pre&gt;&lt;code class=&quot;javascript&quot;&gt;// libs/german.js
exports.hello = function&amp;#40;&amp;#41; {
    return &amp;quot;Hallo&amp;quot;;
};
&lt;/code&gt;&lt;/pre&gt;&lt;pre&gt;&lt;code class=&quot;javascript&quot;&gt;// libs/greeting.js
var german = require&amp;#40;&amp;quot;german&amp;quot;&amp;#41;;

exports.hello = function&amp;#40;name&amp;#41; {
    return german.hello&amp;#40;&amp;#41; + &amp;quot;, &amp;quot; + name;
};
&lt;/code&gt;&lt;/pre&gt;In the example above, we are importing the functionality that is provided by the &lt;code&gt;german&lt;/code&gt; module into the &lt;code&gt;greeting&lt;/code&gt; module. This means, if we would like to use the &lt;code&gt;greeting&lt;/code&gt; module in our ClojureScript project we will need to add both modules to the ClojureScript compiler options, so that the compiler can find the sources.&lt;pre&gt;&lt;code class=&quot;clojure&quot;&gt;&amp;#40;require 'cljs.build.api&amp;#41;

&amp;#40;cljs.build.api/build &amp;quot;src&amp;quot;
  {:main 'hello-world.core
   :output-to &amp;quot;out/main.js&amp;quot;
   :foreign-libs
     &amp;#91;{:file &amp;quot;libs/greeting.js&amp;quot;
       :provides &amp;#91;&amp;quot;greeting&amp;quot;&amp;#93;
       :module-type :commonjs}
      {:file &amp;quot;libs/german.js&amp;quot;
       :provides &amp;#91;&amp;quot;german&amp;quot;&amp;#93;
       :module-type :commonjs}&amp;#93;}&amp;#41;
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;In general, to be able to resolve and check JavaScript dependencies for a ClojureScript namespace, the ClojureScript compiler first constructs a JavaScript dependency index using the compiler options. This index not only contains the dependencies that are passed via the compiler options &lt;code&gt;:foreign-libs&lt;/code&gt; and &lt;code&gt;:libs&lt;/code&gt;, but also contains entries for the modules that are listed in &lt;a href='https://github.com/google/closure-library/blob/master/closure/goog/deps.js'&gt;goog/deps.js&lt;/a&gt;. The dependency index is indexed by namespaces and each entry contains a map with more information about that namespace, e.g. the location of the file or which other modules this namespace requires. For example, for our example above we would like to have entries in the dependency index similar to the following:&lt;/p&gt;&lt;pre&gt;&lt;code class=&quot;clojure&quot;&gt;{...
 greeting
   {:file libs/greeting.js
    :provides &amp;#91;greeting&amp;#93;
    :foreign true
    :url #object&amp;#91;java.net.URL 0x523424b5 file:/Users/marianeise/Documents/development/hello&amp;#95;world/libs/greeting.js&amp;#93;
    :module-type :commonjs
    :requires &amp;#91;german&amp;#93;}
 german
   {:file libs/german.js
    :provides &amp;#91;german&amp;#93;
    :foreign true
    :url #object&amp;#91;java.net.URL 0x523424b5 file:/Users/marianeise/Documents/development/hello&amp;#95;world/libs/german.js&amp;#93;
    :module-type :commonjs
    :requires &amp;#91;&amp;#93;}
...}
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;In the example above, we can see that the map for the &lt;code&gt;greeting&lt;/code&gt; module contains an entry under the &lt;code&gt;:requires&lt;/code&gt; key which holds a vector with all the namespaces that are required. To create this entry, we would need to be able to parse calls to the &lt;code&gt;require&lt;/code&gt; function from CommonJS modules and later also for AMD and ECMAScript 6 modules, which both use a different syntax to import modules. Instead of writing parsers for three different module specifications, we've decided to go with a different approach for now that uses existing functionality. The ClojureScript compiler already includes the functionality to parse the &lt;code&gt;provide&lt;/code&gt; and &lt;code&gt;require&lt;/code&gt; statements from Google Closure-compatible JavaScript files which are included into the project using the &lt;code&gt;:libs&lt;/code&gt; option. As mentioned in my previous post, we are using the Google Closure compiler to convert JavaScript modules to Google Closure modules to be able to include them into a ClojureScript project. This means, before creating the dependency index we convert the CommonJS modules into Google Closure modules and write them to disk.&lt;/p&gt;&lt;pre&gt;&lt;code class=&quot;javascript&quot;&gt;// out/german.js
goog.provide&amp;#40;&amp;quot;module$libs$german&amp;quot;&amp;#41;;
var module$libs$german = {};
module$libs$german.hello = function&amp;#40;&amp;#41; {
  return &amp;quot;Hallo&amp;quot;;
};
&lt;/code&gt;&lt;/pre&gt;&lt;pre&gt;&lt;code class=&quot;javascript&quot;&gt;// out/greeting.js
goog.provide&amp;#40;&amp;quot;module$libs$greeting&amp;quot;&amp;#41;;
var module$libs$greeting = {};
goog.require&amp;#40;&amp;quot;module$libs$german&amp;quot;&amp;#41;;
var german$$module$libs$greeting = module$libs$german;
module$libs$greeting.hello = function&amp;#40;name&amp;#41; {
  return german$$module$libs$greeting.hello&amp;#40;&amp;#41; + &amp;quot;, &amp;quot; + name;
};
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;We now have Google Closure-compatible JavaScript modules and can update the compiler options to look similar to the following:&lt;/p&gt;&lt;pre&gt;&lt;code class=&quot;clojure&quot;&gt;{:output-to &amp;quot;out/main.js&amp;quot;
 :foreign-libs &amp;#91;&amp;#93;
 :libs &amp;#91;&amp;quot;out/greeting.js&amp;quot; &amp;quot;out/german.js&amp;quot;&amp;#93;
 :main 'hello-world.core}
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;Instead of passing the modules as foreign libraries we now pass them via the &lt;code&gt;:libs&lt;/code&gt; compiler option to build the dependency index. Note that also the path to the files has changed to point to the converted version of the modules. This means, the modules will be treated as &quot;normal&quot; Google Closure-compatible JavaScript files by the compiler and the imports for our &lt;code&gt;greeting&lt;/code&gt; module will be extracted successfully. The entries in the JavaScript dependency index will look similar to the following:&lt;/p&gt;&lt;pre&gt;&lt;code class=&quot;clojure&quot;&gt;{...
 module$libs$greeting
   {:requires &amp;#91;module$libs$german&amp;#93;
    :provides &amp;#91;module$libs$greeting&amp;#93;
    :url #object&amp;#91;java.net.URL 0x4a067c25 file:/Users/marianeise/Documents/development/hello&amp;#95;world/out/greeting.js&amp;#93;
    :closure-lib true
    :lib-path out/greeting.js}
 module$libs$german
   {:requires &amp;#91;&amp;#93;
    :provides &amp;#91;module$libs$german&amp;#93;
    :url #object&amp;#91;java.net.URL 0xa1217f9 file:/Users/marianeise/Documents/development/hello&amp;#95;world/out/german.js&amp;#93;
    :closure-lib true
    :lib-path out/german.js}
...}
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;To learn more about the dependency index, have a look at &lt;a href='https://github.com/clojure/clojurescript/blob/master/src/main/clojure/cljs/js&amp;#95;deps.clj'&gt;js&amp;#95;deps.clj&lt;/a&gt; in the ClojureScript project. To see the current progress for this project, have a look at the GitHub &lt;a href='https://github.com/mneise/clojurescript/tree/CLJS-1092'&gt;branch&lt;/a&gt;.&lt;/p&gt;
</description>
<pubDate>
Mon, 08 Jun 2015 00:00:00 -0500
</pubDate>
<author>
Maria Neise
</author>
</item>
<item>
<guid>
http://mneise.github.io/posts/2015-06-02-week-1.html
</guid>
<link>
http://mneise.github.io/posts/2015-06-02-week-1.html
</link>
<title>
GSoC: Week 1
</title>
<description>
&lt;p&gt;&lt;em&gt;I have been accepted to this years Google's Summer of Code to work on ClojureScript. The goal of my project is to improve the integration of ClojureScript with the existing JavaScript ecosystem. I will post weekly updates about the progress of the project here. For more details about the project have a look at the ClojureScript GitHub &lt;a href='https://github.com/clojure/clojurescript/wiki/Google-Summer-of-Code-2015'&gt;wiki page&lt;/a&gt;.&lt;/em&gt;&lt;/p&gt;&lt;p&gt;Last week was the first week of my Google's Summer of Code project. The first part of the project that I will be working on is adding JavaScript module support to ClojureScript, meaning that CommonJS, AMD and ECMAScript 6 modules can be included into a ClojureScript project. For this, we will be using functionality that is already included in the Google Closure compiler. The Google Closure compiler has the classes &lt;code&gt;ProcessCommonJSModules&lt;/code&gt; and &lt;code&gt;ProcessEs6Modules&lt;/code&gt;, which each convert either a CommonJS or ECMAScript 6 module into a Google Closure module. To be able to use those two classes directly from within the ClojureScript compiler, we needed to make the classes and its constructors public. Luckily, our &lt;a href='https://github.com/google/closure-compiler/pull/952'&gt;pull request&lt;/a&gt; to the Google Closure compiler project got accepted and our changes should be included in the next release of the project. With those changes in place, I started off by working on including a CommonJS module into a ClojureScript project. Following, I will try to describe which functionality we will need to add to the ClojurScript compiler so that users can include a CommonJS module without modifying it.&lt;/p&gt;&lt;p&gt;Assume we have the following simple CommonJS module in &lt;code&gt;libs/greeting.js&lt;/code&gt;:&lt;/p&gt;&lt;pre&gt;&lt;code class=&quot;javascript&quot;&gt;exports.hello = function&amp;#40;name&amp;#41; {
    return &amp;quot;Hello, &amp;quot; + name;
};
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;We can include this module as a foreign library. To specify the module type, we will be adding a new compiler option called &lt;code&gt;module-type&lt;/code&gt;, which can have the values &lt;code&gt;:commonjs&lt;/code&gt;, &lt;code&gt;:es6&lt;/code&gt; and &lt;code&gt;:amd&lt;/code&gt;.&lt;/p&gt;&lt;pre&gt;&lt;code class=&quot;clojure&quot;&gt;&amp;#40;require 'cljs.build.api&amp;#41;

&amp;#40;cljs.build.api/build &amp;quot;src&amp;quot;
                      {:main 'hello-world.core
                       :output-to &amp;quot;out/main.js&amp;quot;
                       :foreign-libs &amp;#91;{:file &amp;quot;libs/greeting.js&amp;quot;
                                       :provides &amp;#91;&amp;quot;greeting&amp;quot;&amp;#93;
                                       :module-type :commonjs}&amp;#93;}&amp;#41;
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;To be able to use the functionality provided by the module, we need to require it into our namespace with the same name that we used in the &lt;code&gt;provides&lt;/code&gt; compiler option for the module.&lt;/p&gt;&lt;pre&gt;&lt;code class=&quot;clojure&quot;&gt;&amp;#40;ns hello-world.core
  &amp;#40;:require &amp;#91;greeting&amp;#93;&amp;#41;&amp;#41;

&amp;#40;enable-console-print!&amp;#41;

&amp;#40;println &amp;#40;.hello js/greeting &amp;quot;World!&amp;quot;&amp;#41;&amp;#41;
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;If the ClojureScript compiler would try to handle the module the same way as any other foreign library, we would get the following errors:&lt;/p&gt;&lt;p&gt;&lt;img src=&quot;/images/week1-error1.png&quot; alt=&quot;error 1&quot; /&gt;&lt;/p&gt;&lt;p&gt;We are getting the first error, because the Google Closure dependency management system doesn't implement the CommonJS specification. To get rid of the first error, we need to convert the CommonJS module into a form that is understood by the Google Closure dependency management system and can be used in combination with other Google Closure modules. For this task, we can use the &lt;code&gt;ProcessCommonJSModules&lt;/code&gt; class. Instead of wrapping everything in a function it adds a filename based prefix to the global variables and adds a &lt;code&gt;goog.provide&lt;/code&gt; statement.&lt;/p&gt;&lt;pre&gt;&lt;code class=&quot;javascript&quot;&gt;goog.provide&amp;#40;&amp;quot;module$libs$greeting&amp;quot;&amp;#41;;
var module$libs$greeting = {};
module$libs$greeting.hello = function&amp;#40;name&amp;#41; {
  return &amp;quot;Hello, &amp;quot; + name;
};
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;Converting the CommonJS module helps us to get rid of the &lt;code&gt;exports&lt;/code&gt; error, but we are still left with the &lt;code&gt;greeting is not defined&lt;/code&gt; error. If you have a look at the JavaScript that the compiler emitted, you can see that we are requiring the module as &lt;code&gt;greeting&lt;/code&gt; and later use the &lt;code&gt;greeting&lt;/code&gt; object to call the &lt;code&gt;hello&lt;/code&gt; function on.&lt;/p&gt;&lt;pre&gt;&lt;code class=&quot;javascript&quot;&gt;// Compiled by ClojureScript 0.0-0000 {}
goog.provide&amp;#40;'hello&amp;#95;world.core'&amp;#41;;
goog.require&amp;#40;'cljs.core'&amp;#41;;
goog.require&amp;#40;'greeting'&amp;#41;;
cljs.core.enable&amp;#95;console&amp;#95;print&amp;#95;BANG&amp;#95;.call&amp;#40;null&amp;#41;;
cljs.core.println.call&amp;#40;null,greeting.hello&amp;#40;&amp;quot;World!&amp;quot;&amp;#41;&amp;#41;;

//# sourceMappingURL=core.js.map
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;Looking at the rewritten module code we can see that we should be using &lt;code&gt;module$libs$greeting&lt;/code&gt; to refer to the module instead. This means, in the ClojureScript compiler whenever we see a reference to the module using the &quot;old&quot; name (&lt;code&gt;greeting&lt;/code&gt;) while emitting the JavaScript we need to replace it with the &quot;new&quot; name (&lt;code&gt;module$libs$greeting&lt;/code&gt;).&lt;/p&gt;&lt;pre&gt;&lt;code class=&quot;javascript&quot;&gt;// Compiled by ClojureScript 0.0-0000 {}
goog.provide&amp;#40;'hello&amp;#95;world.core'&amp;#41;;
goog.require&amp;#40;'cljs.core'&amp;#41;;
goog.require&amp;#40;'module$libs$greeting'&amp;#41;;
cljs.core.enable&amp;#95;console&amp;#95;print&amp;#95;BANG&amp;#95;.call&amp;#40;null&amp;#41;;
cljs.core.println.call&amp;#40;null,module$libs$greeting.hello&amp;#40;&amp;quot;World!&amp;quot;&amp;#41;&amp;#41;;

//# sourceMappingURL=core.js.map
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;Finally, we get our &lt;code&gt;Hello, World!&lt;/code&gt;.&lt;/p&gt;&lt;p&gt;&lt;img src=&quot;/images/week1-hello.png&quot; alt=&quot;Hello, World!&quot; /&gt;&lt;/p&gt;&lt;p&gt;To see the current progress, have a look at the GitHub &lt;a href='https://github.com/mneise/clojurescript/tree/CLJS-1092'&gt;branch&lt;/a&gt;.&lt;/p&gt;
</description>
<pubDate>
Tue, 02 Jun 2015 00:00:00 -0500
</pubDate>
<author>
Maria Neise
</author>
</item>
</channel>
</rss>
