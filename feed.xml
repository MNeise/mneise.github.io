<?xml version='1.0' encoding='UTF-8'?>
<rss version='2.0' xmlns:atom='http://www.w3.org/2005/Atom'>
<channel>
<atom:link href='http://mneise.github.io' rel='self' type='application/rss+xml'/>
<generator>
clj-rss
</generator>
<title>
My Dev Blog
</title>
<link>
http://mneise.github.io
</link>
<description>
Some updates and thoughts
</description>
<lastBuildDate>
Thu, 24 Sep 2015 23:11:11 +1200
</lastBuildDate>
<author>
Maria Neise
</author>
<item>
<guid>
http://mneise.github.io/posts/2015-09-05-gsoc-recap.html
</guid>
<link>
http://mneise.github.io/posts/2015-09-05-gsoc-recap.html
</link>
<title>
GSoC Recap
</title>
<description>
&lt;p&gt;Google's Summer of Code has been over for two weeks now. The official &quot;pencils down&quot; date was on August 27th. Since then students were required to submit a final evaluation and some code samples. I want to use this post to look back at the 13 weeks of my Google Summer of Code project and the things we've achieved during this time.&lt;/p&gt;&lt;h5&gt;&lt;a name=&quot;javascript&amp;#95;module&amp;#95;support&quot;&gt;&lt;/a&gt;JavaScript module support&lt;/h5&gt;An important part of the project was to add CommonJS, AMD and ECMAScript 6 support to the ClojureScript compiler. We were able to add the necessary changes for this to the ClojureScript compiler relatively early in week 4. As it turned out, to be able to use this feature with most of the existing JavaScript libraries, we needed to add &lt;a href='https://github.com/google/closure-compiler/pull/1048'&gt;UMD support&lt;/a&gt; to the Google Closure compiler. Additionally, there was a small inconsistency in the way the Google Closure compiler converted JavaScript modules to Google Closure modules which resulted in a &lt;a href='http://dev.clojure.org/jira/browse/CLJS-1314'&gt;problem&lt;/a&gt; when trying to use the converted modules in the ClojureScript Node REPL. Fortunately, we were able to &lt;a href='https://github.com/google/closure-compiler/pull/1071'&gt;fix&lt;/a&gt; this problem. Those changes should be included in the most recent release (&lt;a href='https://github.com/google/closure-compiler/tree/v20150901'&gt;v20150901&lt;/a&gt;) of the Google Closure compiler.&lt;h5&gt;&lt;a name=&quot;javascript&amp;#95;preprocessing&quot;&gt;&lt;/a&gt;JavaScript preprocessing&lt;/h5&gt;Another feature that we added to the ClojureScript compiler is JavaScript preprocessing. For example, this can be useful when you want to include a React component which uses JSX. If you want to know more about this feature, have a look at one of my &lt;a href='http://mneise.github.io/posts/2015-08-04-week-9-and-10.html'&gt;previous posts&lt;/a&gt;.&lt;h5&gt;&lt;a name=&quot;externs&amp;#95;inference&quot;&gt;&lt;/a&gt;Externs inference&lt;/h5&gt;Finally, we started to work on externs inference, meaning that externs should be generated automatically based on the use of JavaScript interop. We already have a &lt;a href='https://github.com/clojure/clojurescript/compare/master...mneise:CLJS-1074'&gt;first working version&lt;/a&gt; of this feature for simple JavaScript interop, such as &lt;code&gt;&amp;#40;.-bar js/foo&amp;#41;&lt;/code&gt;. However, before this feature can be merged, we still need to add support for generating externs for more complicated uses of JavaScript interop and would also like to add an extern type hint.&lt;h5&gt;&lt;a name=&quot;what's&amp;#95;next?&quot;&gt;&lt;/a&gt;What's next?&lt;/h5&gt;I've been back at work for two weeks now and Uni has also already started three weeks ago. I've decided to take only one class this semester, &lt;a href='http://www.omscs.gatech.edu/cs-6475-computational-photography/'&gt;Computational Photography&lt;/a&gt;, to be able to continue contributing to the ClojureScript compiler and working on the externs inference task. Additionally, I have volunteered to maintain &lt;a href='https://github.com/emezeske/lein-cljsbuild'&gt;lein-cljsbuild&lt;/a&gt;, which I am very excited about :).
</description>
<pubDate>
Sat, 05 Sep 2015 00:00:00 +1200
</pubDate>
<author>
Maria Neise
</author>
</item>
<item>
<guid>
http://mneise.github.io/posts/2015-08-04-week-9-and-10.html
</guid>
<link>
http://mneise.github.io/posts/2015-08-04-week-9-and-10.html
</link>
<title>
GSoC: Week 9/10 - Support for JavaScript transforms
</title>
<description>
&lt;p&gt;&lt;em&gt;I have been accepted to this years Google's Summer of Code to work on ClojureScript. The goal of my project is to improve the integration of ClojureScript with the existing JavaScript ecosystem. I will post weekly updates about the progress of the project here. For more details about the project have a look at the ClojureScript GitHub &lt;a href='https://github.com/clojure/clojurescript/wiki/Google-Summer-of-Code-2015'&gt;wiki page&lt;/a&gt;.&lt;/em&gt;&lt;/p&gt;&lt;p&gt;ClojureScript 1.7.48 comes with a new feature that allows you to add a custom transformation step for JavaScript libraries. This means that you are now able to include JavaScript libraries in your project which are written in a dialect or make use of a syntax extension. In this post I will show you a small example how to use this feature to include an existing React component which uses JSX. The component we want to include creates a small SVG circle that sets the color of the circle from a property.&lt;/p&gt;&lt;pre&gt;&lt;code class=&quot;javascript&quot;&gt;// Circle.js
var React = require&amp;#40;'./react'&amp;#41;;

var Circle = React.createClass&amp;#40;{
  render: function&amp;#40;&amp;#41; {
    return&amp;#40;
      &amp;lt;svg width=&amp;quot;200px&amp;quot; height=&amp;quot;200px&amp;quot; className=&amp;quot;center&amp;quot;&amp;gt;
        &amp;lt;circle cx=&amp;quot;100px&amp;quot; cy=&amp;quot;100px&amp;quot; r=&amp;quot;100px&amp;quot; fill={this.props.color}&amp;gt;
        &amp;lt;/circle&amp;gt;
      &amp;lt;/svg&amp;gt;
    &amp;#41;;
  }
}&amp;#41;;

module.exports = Circle;
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;We will use this component to create a small ClojureScript project that will allow us you to change the color of the circle by specifying it via a text input field. We can include this component in our project by using the following compiler options:&lt;/p&gt;&lt;pre&gt;&lt;code class=&quot;clojure&quot;&gt;;; build.clj
&amp;#40;require '&amp;#91;cljs.build.api :as b&amp;#93;
         '&amp;#91;clojure.java.io :as io&amp;#93;&amp;#41;
&amp;#40;refer 'cljs.closure :only '&amp;#91;js-transforms&amp;#93;&amp;#41;
&amp;#40;import 'javax.script.ScriptEngineManager&amp;#41;

&amp;#40;defmethod js-transforms :jsx &amp;#91;ijs opts&amp;#93;
  &amp;#40;let &amp;#91;engine &amp;#40;doto &amp;#40;.getEngineByName &amp;#40;ScriptEngineManager.&amp;#41; &amp;quot;nashorn&amp;quot;&amp;#41;
                 &amp;#40;.eval &amp;#40;io/reader &amp;#40;io/file &amp;quot;jstransform-simple.bundle.js&amp;quot;&amp;#41;&amp;#41;&amp;#41;
                 &amp;#40;.put &amp;quot;originalCode&amp;quot; &amp;#40;:source ijs&amp;#41;&amp;#41;&amp;#41;&amp;#93;
    &amp;#40;assoc ijs :source
      &amp;#40;.eval engine &amp;#40;str &amp;quot;simple.transform&amp;#40;originalCode, {react: true}&amp;#41;.code&amp;quot;&amp;#41;&amp;#41;&amp;#41;&amp;#41;&amp;#41;

&amp;#40;b/build &amp;quot;src&amp;quot;
  {:main 'circle-color.core
   :asset-path &amp;quot;js/out&amp;quot;
   :output-to &amp;quot;resources/public/js/out/circle&amp;#95;color.js&amp;quot;
   :output-dir &amp;quot;resources/public/js/out&amp;quot;
   :verbose true
   :pretty-print true
   :foreign-libs &amp;#91;{:file &amp;quot;resources/public/js/libs/react.js&amp;quot;
                   :provides &amp;#91;&amp;quot;React&amp;quot;&amp;#93;
                   :module-type :commonjs}
                  {:file &amp;quot;resources/public/js/libs/Circle.js&amp;quot;
                   :provides &amp;#91;&amp;quot;Circle&amp;quot;&amp;#93;
                   :module-type :commonjs
                   :preprocess :jsx}&amp;#93;
   :closure-warnings {:non-standard-jsdoc :off}}&amp;#41;
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;Both, React and the Circle component are included as CommonJS libraries, meaning that they will be converted to Google Closure modules. However, the important thing to notice here is that we are specifying an additional &lt;code&gt;:preprocess&lt;/code&gt; option for the Circle component and are adding a new &lt;code&gt;js-transforms&lt;/code&gt; method for the &lt;code&gt;:jsx&lt;/code&gt; dispatch-value. This is the part where the transformation happens. &lt;code&gt;js-transforms&lt;/code&gt; gets and returns an object which satisfies the &lt;code&gt;IJavaScript&lt;/code&gt; protocol and can be a plain map or a record with keys like &lt;code&gt;:url&lt;/code&gt;, &lt;code&gt;:provides&lt;/code&gt;, &lt;code&gt;:requires&lt;/code&gt; and &lt;code&gt;:source&lt;/code&gt;. We will get the JavaScript code from the &lt;code&gt;:source&lt;/code&gt; key, transform it and then return the &lt;code&gt;IJavaScript&lt;/code&gt; instance with the transformed code set as &lt;code&gt;:source&lt;/code&gt;. To transform the source code, we are using &lt;a href='https://github.com/facebook/jstransform'&gt;facebook's JSTransform&lt;/a&gt; (which we've bundled) and are evaluating it using Nashorn. When we are now building our project, each foreign library will be checked for a &lt;code&gt;:preprocess&lt;/code&gt; option and will then be passed to the &lt;code&gt;js-transforms&lt;/code&gt; mutlimethod which uses the value of the &lt;code&gt;:preprocess&lt;/code&gt; option as a dispatch-value. This happens before module conversion, however, both steps are independent of each other and can be used in disjunction.&lt;/p&gt;&lt;p&gt;Transforming the Circle component to plain JavaScript and then to a Google Closure module, allows us to use it in our ClojurScript project as follows:&lt;/p&gt;&lt;pre&gt;&lt;code class=&quot;clojure&quot;&gt;;; core.cljs
&amp;#40;ns circle-color.core
  &amp;#40;:require &amp;#91;clojure.browser.repl :as repl&amp;#93;
            &amp;#91;React :refer &amp;#91;createElement createClass render&amp;#93;&amp;#93;
            &amp;#91;Circle :as Circle&amp;#93;&amp;#41;&amp;#41;

&amp;#40;def ColorInput
  &amp;#40;createClass
   #js {:render
        &amp;#40;fn &amp;#91;&amp;#93;
          &amp;#40;this-as this
            &amp;#40;createElement &amp;quot;div&amp;quot; nil
              &amp;#40;createElement &amp;quot;input&amp;quot; #js {:type &amp;quot;text&amp;quot;
                                          :className &amp;quot;center&amp;quot;
                                          :onChange &amp;#40;.. this -props -onChange&amp;#41;}&amp;#41;&amp;#41;&amp;#41;&amp;#41;}&amp;#41;&amp;#41;

&amp;#40;def Container
  &amp;#40;createClass
   #js {:getInitialState &amp;#40;fn &amp;#91;&amp;#93; #js {:color &amp;quot;&amp;quot;}&amp;#41;
        :handleColorChange &amp;#40;fn &amp;#91;event&amp;#93;
                             &amp;#40;this-as this
                               &amp;#40;.setState this #js {:color &amp;#40;.. event -target -value&amp;#41;}&amp;#41;&amp;#41;&amp;#41;
        :render &amp;#40;fn &amp;#91;&amp;#93;
                  &amp;#40;this-as this
                    &amp;#40;createElement &amp;quot;div&amp;quot; nil
                      &amp;#40;createElement ColorInput #js {:onChange &amp;#40;. this -handleColorChange&amp;#41;}&amp;#41;
                      &amp;#40;createElement js/Circle #js {:color &amp;#40;.. this -state -color&amp;#41;}&amp;#41;&amp;#41;&amp;#41;&amp;#41;}&amp;#41;&amp;#41;

&amp;#40;render
 &amp;#40;createElement Container&amp;#41;
 &amp;#40;.getElementById js/document &amp;quot;app&amp;quot;&amp;#41;&amp;#41;

&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;We are creating two additional components, the &lt;code&gt;ColorInput&lt;/code&gt; component, where we will specify the color of the circle, and a &lt;code&gt;Container&lt;/code&gt; component which will hold the &lt;code&gt;ColorInput&lt;/code&gt; and the &lt;code&gt;Circle&lt;/code&gt; component and will pass the color property to the &lt;code&gt;Circle&lt;/code&gt; component. And this is our final result:&lt;/p&gt;&lt;p&gt;&lt;div id=&quot;app&quot;&gt; &lt;/div&gt; &lt;script src=&quot;../js/circle_color.js&quot;&gt;&lt;/script&gt;&lt;/p&gt;&lt;p&gt;To check out the code and try this example, have a look at the project on &lt;a href='https://github.com/mneise/circle-color'&gt;GitHub&lt;/a&gt;. This example requires a custom build of the Google Closure compiler with UMD support. This is needed to be able to successfully convert React to a Google Closure module. We already made a &lt;a href='https://github.com/google/closure-compiler/pull/1048'&gt;pull request&lt;/a&gt; for this, but it has not been merged into the Google Closure compiler yet. Also, it is currently not possible to load &lt;a href='http://dev.clojure.org/jira/browse/CLJS-1322'&gt;Babel into Nashorn&lt;/a&gt; to transform JavaScript, since it will throw a &lt;code&gt;Method code too large!&lt;/code&gt; exception.&lt;/p&gt;
</description>
<pubDate>
Tue, 04 Aug 2015 00:00:00 +1200
</pubDate>
<author>
Maria Neise
</author>
</item>
<item>
<guid>
http://mneise.github.io/posts/2015-07-23-week-7-and-8.html
</guid>
<link>
http://mneise.github.io/posts/2015-07-23-week-7-and-8.html
</link>
<title>
GSoC: Week 7/8 - Clojure Berlin &amp; Google Closure compiler
</title>
<description>
&lt;p&gt;&lt;em&gt;I have been accepted to this years Google's Summer of Code to work on ClojureScript. The goal of my project is to improve the integration of ClojureScript with the existing JavaScript ecosystem. I will post weekly updates about the progress of the project here. For more details about the project have a look at the ClojureScript GitHub &lt;a href='https://github.com/clojure/clojurescript/wiki/Google-Summer-of-Code-2015'&gt;wiki page&lt;/a&gt;.&lt;/em&gt;&lt;/p&gt;&lt;p&gt;Writing those posts still takes me some time since writing doesn't come natural to me. Or maybe it's because English is not my first language. So, I didn't write a post for week 7, because I already spent some time on preparing slides about GSoC, and wanted to use the rest of the time for coding. Long story short, I now have a more time again, so here goes the post for week 7 and 8 ;)&lt;/p&gt;&lt;h4&gt;&lt;a name=&quot;clojurebridge&amp;#95;berlin&amp;#95;and&amp;#95;clojure&amp;#95;berlin&amp;#95;dojo&quot;&gt;&lt;/a&gt;ClojureBridge Berlin and Clojure Berlin Dojo&lt;/h4&gt;&lt;p&gt;I was in Berlin during the last couple of weeks. During this time I was lucky enough to meet some great people (&lt;a href='https://twitter.com/malweene'&gt;Malwine&lt;/a&gt;, &lt;a href='https://twitter.com/martinklepsch'&gt;Martin&lt;/a&gt; and &lt;a href='https://twitter.com/jellea'&gt;Jelle&lt;/a&gt; to only mention a few) from the Berlin Clojure community and gave two talks about GSoC and my project. The first talk was a short lightning talk at the &lt;a href='http://www.clojurebridge.org/events/2015-07-10-berlin'&gt;Clojure Bridge Berlin workshop&lt;/a&gt; and was intended to inform the attendees about the GSoC program and motivate them to apply. I've also managed to sneak some ClojureScript into the talk and tried to explain what ClojureScript is about :)&lt;/p&gt;&lt;p&gt;&lt;blockquote class=&quot;twitter-tweet tw-align-center&quot; lang=&quot;en&quot; width=&quot;400&quot;&gt;&lt;p lang=&quot;en&quot; dir=&quot;ltr&quot;&gt;A very motivational talk by &lt;a href=&quot;https://twitter.com/mayaneise&quot;&gt;@mayaneise&lt;/a&gt; about Google Summer of Code at &lt;a href=&quot;https://twitter.com/hashtag/ClojureBridge?src=hash&quot;&gt;#ClojureBridge&lt;/a&gt; Berlin &lt;a href=&quot;http://t.co/ZSQSApGFZO&quot;&gt;pic.twitter.com/ZSQSApGFZO&lt;/a&gt;&lt;/p&gt;&amp;mdash; Clojure Berlin (@ClojureBerlin) &lt;a href=&quot;https://twitter.com/ClojureBerlin/status/619847638574329857&quot;&gt;July 11, 2015&lt;/a&gt;&lt;/blockquote&gt; &lt;script async src=&quot;//platform.twitter.com/widgets.js&quot; charset=&quot;utf-8&quot;&gt;&lt;/script&gt;&lt;/p&gt;&lt;p&gt;The second talk was at the &lt;a href='http://www.meetup.com/Clojure-Berlin/events/222655704/'&gt;Clojure Berlin Dojo&lt;/a&gt; meetup and was more focused on the project itself rather than the GSoC program. Personally, I wasn't sure if I put too much/little detail into the talk, but people seemed to be interested, since there were some questions afterwards. Overall, it was really great meeting people I've only known from the Internet so far and everyone was as nice and welcoming as they are online.&lt;/p&gt;&lt;h4&gt;&lt;a name=&quot;google&amp;#95;closure&amp;#95;compiler&quot;&gt;&lt;/a&gt;Google Closure compiler&lt;/h4&gt;&lt;p&gt;Regarding the progress of the project, we managed to fix two bugs. The first one was a &lt;a href='http://dev.clojure.org/jira/browse/CLJS-1341'&gt;CommonJS processing bug&lt;/a&gt; in the ClojureScript compiler, where we were invoking a Google Closure compiler method to convert an AMD module to a CommonJS module even if the module was already a CommonJS module. The second was a &lt;a href='https://github.com/google/closure-compiler/pull/1042'&gt;bug in the Google Closure compiler&lt;/a&gt; that occurred when converting a CommonJS module to a Google Closure module. This bug fix is one of two that brings us a step closer to being able to convert more complex JavaScript libraries, such as React.js, to Google Closure modules. The other fix is still outstanding, meaning that the pull request to the Google Closure compiler has not been merged yet, and &lt;a href='https://github.com/google/closure-compiler/pull/1048'&gt;targets JavaScript libraries that are using the UMD pattern&lt;/a&gt;.&lt;/p&gt;&lt;p&gt;Additionally, some functionality of the Google Closure compiler, that we are using to convert JavaScript modules to Google Closure modules, has been rewritten and improved. So we needed to figure out how those changes would affect us and as it turns out, we will need to do some refactoring to be able to use the Google Closure compiler for converting JavaScript modules. If you want to learn more about the changes to the Google Closure compiler, check out the &lt;a href='https://github.com/google/closure-compiler/pull/1043'&gt;pull request&lt;/a&gt; or have a look at the &lt;a href='https://groups.google.com/forum/#!topic/closure-compiler-discuss/gI5Pwoz4Upc'&gt;Google Closure compiler mailing list thread&lt;/a&gt;.&lt;/p&gt;
</description>
<pubDate>
Thu, 23 Jul 2015 00:00:00 +1200
</pubDate>
<author>
Maria Neise
</author>
</item>
<item>
<guid>
http://mneise.github.io/posts/2015-07-08-week-6.html
</guid>
<link>
http://mneise.github.io/posts/2015-07-08-week-6.html
</link>
<title>
GSoC: Week 6 - UMD pattern
</title>
<description>
&lt;p&gt;&lt;em&gt;I have been accepted to this years Google's Summer of Code to work on ClojureScript. The goal of my project is to improve the integration of ClojureScript with the existing JavaScript ecosystem. I will post weekly updates about the progress of the project here. For more details about the project have a look at the ClojureScript GitHub &lt;a href='https://github.com/clojure/clojurescript/wiki/Google-Summer-of-Code-2015'&gt;wiki page&lt;/a&gt;.&lt;/em&gt;&lt;/p&gt;&lt;p&gt;In this post I will write a bit about the midterm evaluations and also about the UMD pattern.&lt;/p&gt;&lt;h4&gt;&lt;a name=&quot;midterm&amp;#95;evaluations&quot;&gt;&lt;/a&gt;Midterm evaluations&lt;/h4&gt;&lt;p&gt;The Google Summer of Code midterm evaluations were due last Friday (July 3rd), meaning that every student and every mentor had to submit an evaluation about the current progress of their project and students had to evaluate their mentor(s) and vice versa. In almost all cases, students will never see the mentor's evaluation and a mentor will never see the student's evaluation. Only the GSoC program administrators have access to all the evaluation data. Students will only receive an email notifying them if they have passed or failed the midterm evaluation. So, it is recommended that students talk directly to their mentor and ask about feedback. My mentor, David Nolen, and I have been trying to do this throughout the project, and I am happy to announce that I have passed my midterm evaluation :).&lt;/p&gt;&lt;h4&gt;&lt;a name=&quot;umd&quot;&gt;&lt;/a&gt;UMD&lt;/h4&gt;&lt;p&gt;To test the CommonJS and AMD support, I checked &lt;a href='https://github.com/cljsjs/packages'&gt;CLJSJS&lt;/a&gt; for JavaScript libraries and tried to include them into a ClojureScript project using the CommonJS or AMD module compiler option. For example, I tried to include &lt;a href='http://d3js.org/'&gt;d3&lt;/a&gt;, &lt;a href='http://hammerjs.github.io/'&gt;hammerjs&lt;/a&gt;, &lt;a href='http://chancejs.com/'&gt;Chance&lt;/a&gt; and &lt;a href='https://codemirror.net/index.html'&gt;CodeMirror&lt;/a&gt;. The following is a small example which uses d3 to change the color of a circle depending on the value given in an input field.&lt;/p&gt;&lt;pre&gt;&lt;code class=&quot;clojure&quot;&gt;;; build.clj
&amp;#40;require 'cljs.build.api&amp;#41;

&amp;#40;cljs.build.api/build &amp;quot;src&amp;quot;
                      {:main 'hello-world.core
                       :output-to &amp;quot;out/main.js&amp;quot;
                       :output-dir &amp;quot;out&amp;quot;
                       :foreign-libs &amp;#91;{:file &amp;quot;libs/d3.js&amp;quot;
                                       :provides &amp;#91;&amp;quot;d3&amp;quot;&amp;#93;
                                       :module-type :commonjs}&amp;#93;
                       :source-map &amp;quot;out/map.js&amp;quot;
                       :optimizations :none}&amp;#41;
&lt;/code&gt;&lt;/pre&gt;&lt;pre&gt;&lt;code class=&quot;clojure&quot;&gt;;; core.cljs
&amp;#40;ns hello-world.core
  &amp;#40;:require &amp;#91;d3 :as d3&amp;#93;&amp;#41;&amp;#41;

&amp;#40;enable-console-print!&amp;#41;

&amp;#40;def center #js {:margin-left &amp;quot;auto&amp;quot;
                 :margin-right &amp;quot;auto&amp;quot;
                 :display &amp;quot;block&amp;quot;}&amp;#41;

&amp;#40;def body &amp;#40;d3/select &amp;quot;body&amp;quot;&amp;#41;&amp;#41;

&amp;#40;def p &amp;#40;-&amp;gt; body
           &amp;#40;.append &amp;quot;p&amp;quot;&amp;#41;
           &amp;#40;.text &amp;quot;Change the color of the circle: &amp;quot;&amp;#41;
           &amp;#40;.attr &amp;quot;align&amp;quot; &amp;quot;center&amp;quot;&amp;#41;&amp;#41;&amp;#41;

&amp;#40;def color-input &amp;#40;-&amp;gt; p
                     &amp;#40;.append &amp;quot;input&amp;quot;&amp;#41;
                     &amp;#40;.attr #js {:type &amp;quot;text&amp;quot;
                                 :id &amp;quot;color&amp;quot;}&amp;#41;&amp;#41;&amp;#41;

&amp;#40;def svg &amp;#40;-&amp;gt; body
             &amp;#40;.append &amp;quot;svg&amp;quot;&amp;#41;
             &amp;#40;.attr #js {:width &amp;quot;300px&amp;quot;
                         :height &amp;quot;300px&amp;quot;}&amp;#41;
             &amp;#40;.style center&amp;#41;&amp;#41;&amp;#41;

&amp;#40;def circle &amp;#40;-&amp;gt; svg
                &amp;#40;.append &amp;quot;circle&amp;quot;&amp;#41;
                &amp;#40;.attr #js {:cx &amp;quot;50%&amp;quot;
                            :cy &amp;quot;50%&amp;quot;
                            :r 120}&amp;#41;
                &amp;#40;.style #js {:fill &amp;quot;black&amp;quot;}&amp;#41;&amp;#41;&amp;#41;

&amp;#40;defn update-color &amp;#91;color&amp;#93;
  &amp;#40;-&amp;gt; circle
      .transition
      &amp;#40;.delay 250&amp;#41;
      &amp;#40;.duration 500&amp;#41;
      &amp;#40;.style #js {:fill color}&amp;#41;&amp;#41;&amp;#41;

&amp;#40;.on color-input &amp;quot;input&amp;quot; #&amp;#40;-&amp;gt; &amp;#40;.-value &amp;#40;.getElementById js/document &amp;quot;color&amp;quot;&amp;#41;&amp;#41;
                              update-color&amp;#41;&amp;#41;
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;Unfortunately, when we compile our example and then try to run it in the browser, we get the following error:&lt;/p&gt;&lt;p&gt;&lt;img src=&quot;/images/week6-error.png&quot; alt=&quot;d3 error&quot; /&gt;&lt;/p&gt;&lt;p&gt;Let's have a look at the source code.&lt;/p&gt;&lt;p&gt;&lt;img src=&quot;/images/week6-error2.png&quot; alt=&quot;d3 error&quot; /&gt;&lt;/p&gt;&lt;p&gt;It seems that we get an error when trying to access d3. The compiled JavaScript for this looks as follows.&lt;/p&gt;&lt;pre&gt;&lt;code class=&quot;clojure&quot;&gt;hello&amp;#95;world.core.body = module$libs$d3.select.call&amp;#40;null,&amp;quot;body&amp;quot;&amp;#41;;
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;This looks good so far. Let's have a closer look at the &lt;code&gt;module$libs$d3&lt;/code&gt;.&lt;/p&gt;&lt;p&gt;&lt;img src=&quot;/images/week6-empty.png&quot; alt=&quot;d3 empty object&quot; /&gt;&lt;/p&gt;&lt;p&gt;Oh, what happened there? Why is &lt;code&gt;module$libs$d3&lt;/code&gt; an empty object? If we have a look at the code of the d3 module which was converted with the Google Closure compiler, we can see the following.&lt;/p&gt;&lt;pre&gt;&lt;code class=&quot;javascript&quot;&gt;if &amp;#40;typeof define === &amp;quot;function&amp;quot; &amp;amp;&amp;amp; define.amd&amp;#41; {
    define&amp;#40;d3&amp;#41;;
} else if &amp;#40;typeof module === &amp;quot;object&amp;quot; &amp;amp;&amp;amp; module$libs$d3&amp;#41; {
    module$libs$d3 = d3
}
&lt;/code&gt;&lt;/pre&gt;The code is checking if &lt;code&gt;module&lt;/code&gt; is an object and only then assigns whatever the variable d3 holds to our new namespace &lt;code&gt;module$libs$d3&lt;/code&gt;. Unfortunately, &lt;code&gt;module&lt;/code&gt; will not be defined in the browser so our &lt;code&gt;module$libs$d3&lt;/code&gt; namespace will remain empty. Here is the original code of the d3 library.&lt;pre&gt;&lt;code class=&quot;javascript&quot;&gt;if &amp;#40;typeof define === &amp;quot;function&amp;quot; &amp;amp;&amp;amp; define.amd&amp;#41; {
    define&amp;#40;d3&amp;#41;;
} else if &amp;#40;typeof module === &amp;quot;object&amp;quot; &amp;amp;&amp;amp; module.exports&amp;#41; {
    module.exports = d3;
}
&lt;/code&gt;&lt;/pre&gt;This is a common JavaScript idiom, which is called &lt;a href='http://davidbcalhoun.com/2014/what-is-amd-commonjs-and-umd/'&gt;UMD&lt;/a&gt; (Universal Module Definition). The goal of the UMD pattern is to support AMD as well as CommonJS, since both module specifications have become quite popular over time. Not just d3, but many other libraries use the UMD pattern, in fact all four libraries mentioned above use some variant of the UMD pattern. Unfortunately, this also means, that we can't include any of those libraries using the new &lt;code&gt;module-type&lt;/code&gt; compiler option. For this to work, we will hopefully submit another pull request to the Google Closure compiler soon with some modifications to the &lt;code&gt;ProcessCommonJSModules&lt;/code&gt; class.
</description>
<pubDate>
Wed, 08 Jul 2015 00:00:00 +1200
</pubDate>
<author>
Maria Neise
</author>
</item>
<item>
<guid>
http://mneise.github.io/posts/2015-06-29-week-5.html
</guid>
<link>
http://mneise.github.io/posts/2015-06-29-week-5.html
</link>
<title>
GSoC: Week 5 - Midterm evaluations
</title>
<description>
&lt;p&gt;&lt;em&gt;I have been accepted to this years Google's Summer of Code to work on ClojureScript. The goal of my project is to improve the integration of ClojureScript with the existing JavaScript ecosystem. I will post weekly updates about the progress of the project here. For more details about the project have a look at the ClojureScript GitHub &lt;a href='https://github.com/clojure/clojurescript/wiki/Google-Summer-of-Code-2015'&gt;wiki page&lt;/a&gt;.&lt;/em&gt;&lt;/p&gt;&lt;p&gt;The Google Summer of Code student midterm evaluations are due this week on 3 July 2015 at 19:00 UTC, so I will use this post to write about my experience with the Google Summer of Code program, reflect on the previous 5 weeks and talk about the tasks for the next following 8 weeks.&lt;/p&gt;&lt;p&gt;The Google Summer of Code program has been a great opportunity for me to start contributing to open source and to connect with the Clojure community. Many great projects have come out of it, such as &lt;a href='https://twitter.com/ambrosebs'&gt;Ambrose Bonnaire-Sergeant's&lt;/a&gt; &lt;a href='http://typedclojure.org/'&gt;Typed Clojure&lt;/a&gt;, and students as well as organizations are benefiting from GSoC. As much as I value the GSoC program, there is still room for improvement. In particular, communication between GSoC students is not promoted by the program organizers which is likely one reason for the lack of community between GSoC students.&lt;/p&gt;&lt;p&gt;Then again, the Clojure and ClojureScript community has been really welcoming and helpful. Many people seem to be excited about this project and I've only had positive interactions with other Clojurians so far. My mentor for this project, &lt;a href='https://twitter.com/swannodette'&gt;David Nolen&lt;/a&gt;, has been more than helpful, very responsive and has been doing a lot to promote this GSoC project. Also, a big thank you to &lt;a href='https://twitter.com/mfikes'&gt;Mike Fikes&lt;/a&gt;, who has been trying out the CommonJS support in &lt;a href='http://blog.fikesfarm.com/posts/2015-06-17-commonjs-libs-in-ambly.html'&gt;Ambly&lt;/a&gt; and has given me very valuable feedback.&lt;/p&gt;&lt;p&gt;Regarding the project itself, we are making good progress and are sticking to the estimated schedule. We've added support for CommonJS, AMD and ECMAScript 2015 to ClojureScript and submitted two pull requests to the Google Closure compiler. For the following weeks, we will continue to improve the JavaScript module support and will work on generating externs for foreign libraries. So stay tuned, there is more to come ;)&lt;/p&gt;
</description>
<pubDate>
Mon, 29 Jun 2015 00:00:00 +1200
</pubDate>
<author>
Maria Neise
</author>
</item>
<item>
<guid>
http://mneise.github.io/posts/2015-06-22-week-4.html
</guid>
<link>
http://mneise.github.io/posts/2015-06-22-week-4.html
</link>
<title>
GSoC: Week 4 - Adding AMD and ECMAScript 2015 support
</title>
<description>
&lt;p&gt;&lt;em&gt;I have been accepted to this years Google's Summer of Code to work on ClojureScript. The goal of my project is to improve the integration of ClojureScript with the existing JavaScript ecosystem. I will post weekly updates about the progress of the project here. For more details about the project have a look at the ClojureScript GitHub &lt;a href='https://github.com/clojure/clojurescript/wiki/Google-Summer-of-Code-2015'&gt;wiki page&lt;/a&gt;.&lt;/em&gt;&lt;/p&gt;&lt;p&gt;Last week, we made further progress in adding JavaScript module support to ClojureScript. David merged two patches, one for &lt;a href='https://github.com/clojure/clojurescript/commit/87f39511a54d7b91ae86f581fda90f280f985816'&gt;AMD module support&lt;/a&gt; and the other for &lt;a href='https://github.com/clojure/clojurescript/commit/ac0b169cb082bd2ff4ac917274cb91628adba947'&gt;ECMAScript 2015 module support&lt;/a&gt;. In this post, I will describe how to use AMD and ECMAScript 2015 modules in a ClojureScript project.&lt;/p&gt;&lt;h4&gt;&lt;a name=&quot;amd&quot;&gt;&lt;/a&gt;AMD&lt;/h4&gt;&lt;p&gt;Adding support for AMD is very similar to adding support for CommonJS. The only difference is that we first rewrite an AMD module to a CommonJS module before converting it to a Google Closure module. Both can be done with the Google Closure compiler. Currently, the Google Closure compiler supports the following AMD &lt;code&gt;define&lt;/code&gt; signatures:&lt;/p&gt;&lt;pre&gt;&lt;code&gt;define&amp;#40;function&amp;#40;&amp;#41; ...&amp;#41;
define&amp;#40;OBJECT&amp;#95;LITERAL&amp;#41;
define&amp;#40;&amp;#91;'dep', 'dep1'&amp;#93;, function&amp;#40;d0, d2, &amp;#91;exports, module&amp;#93;&amp;#41; ...&amp;#41;
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;For example, the following is an AMD module that can be processed by the Google Closure compiler:&lt;/p&gt;&lt;pre&gt;&lt;code class=&quot;javascript&quot;&gt;// greeting.js
define&amp;#40;function &amp;#40;&amp;#41; {
    return {
        hello: function &amp;#40;name&amp;#41; {
            return &amp;quot;Hello, &amp;quot; + name;
        }
    };
}&amp;#41;;
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;To be able to include this module, we need to build our own version of the Google Closure compiler and the ClojureScript compiler. The reason for this is that we are using the package private class &lt;code&gt;TransformAMDToCJModules&lt;/code&gt; from the Google Closure compiler to rewrite an AMD module to a CommonJS module. We need to make the class and its constructor public to be able to use this functionality. We have already submitted a &lt;a href='https://github.com/google/closure-compiler/pull/1012'&gt;patch&lt;/a&gt; for this and the change will hopefully be merged and included in the next release of the Google Closure compiler. But for now, clone the Google Closure compiler repository, build it and install it to your local maven repository as follows:&lt;/p&gt;&lt;pre&gt;&lt;code&gt;$ git clone git@github.com:google/closure-compiler.git
$ cd closure-compiler
$ ant jar
$ mvn install:install-file -Dfile=build/compiler.jar -DgroupId=com.google.javascript -DartifactId=closure-compiler -Dversion=v20150622-SNAPSHOT -Dpackaging=jar
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;Before building a new version of the ClojureScript compiler (see the previous &lt;a href='http://mneise.github.io/posts/2015-06-15-week-3.html'&gt;post&lt;/a&gt;) change the version of the Google Closure compiler in ClojureScript's &lt;code&gt;project.clj&lt;/code&gt; file to the same version you used to install the Google Closure compiler JAR to your local maven repository, for example:&lt;/p&gt;&lt;pre&gt;&lt;code class=&quot;clojure&quot;&gt;&amp;#91;com.google.javascript/closure-compiler &amp;quot;v20150622-SNAPSHOT&amp;quot;&amp;#93;
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;Finally, include the AMD module with the new compiler option &lt;code&gt;module-type&lt;/code&gt; and the value &lt;code&gt;:amd&lt;/code&gt;:&lt;/p&gt;&lt;pre&gt;&lt;code class=&quot;clojure&quot;&gt;:foreign-libs &amp;#91;{:file &amp;quot;libs/greeting.js&amp;quot;
                :provides &amp;#91;&amp;quot;greeting&amp;quot;&amp;#93;
                :module-type :amd}&amp;#93;
&lt;/code&gt;&lt;/pre&gt;&lt;h4&gt;&lt;a name=&quot;ecmascript&amp;#95;2015&quot;&gt;&lt;/a&gt;ECMAScript 2015&lt;/h4&gt;&lt;p&gt;The Google Closure compiler includes the functionality to transpile from ECMAScript 2015 to a lower version. We are using this functionality to add support for ECMAScript 2015 modules and are converting ECMAScript 2015 modules to Google Closure ECMAScript 5 modules.&lt;/p&gt;&lt;pre&gt;&lt;code class=&quot;javascript&quot;&gt;// greeting.js
export function hello&amp;#40;name&amp;#41; {
    return &amp;quot;Hello, &amp;quot; + name;
};
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;To include the above module, we need to build a recent version of the ClojureScript compiler (see the previous &lt;a href='http://mneise.github.io/posts/2015-06-15-week-3.html'&gt;post&lt;/a&gt;) and use the new compiler option &lt;code&gt;module-type&lt;/code&gt; with the value &lt;code&gt;:es6&lt;/code&gt;:&lt;/p&gt;&lt;pre&gt;&lt;code class=&quot;clojure&quot;&gt;:foreign-libs &amp;#91;{:file &amp;quot;libs/greeting.js&amp;quot;
                :provides &amp;#91;&amp;quot;greeting&amp;quot;&amp;#93;
                :module-type :es6}&amp;#93;
&lt;/code&gt;&lt;/pre&gt;
</description>
<pubDate>
Mon, 22 Jun 2015 00:00:00 +1200
</pubDate>
<author>
Maria Neise
</author>
</item>
<item>
<guid>
http://mneise.github.io/posts/2015-06-15-week-3.html
</guid>
<link>
http://mneise.github.io/posts/2015-06-15-week-3.html
</link>
<title>
GSoC: Week 3 - Adding CommonJS support
</title>
<description>
&lt;p&gt;&lt;em&gt;I have been accepted to this years Google's Summer of Code to work on ClojureScript. The goal of my project is to improve the integration of ClojureScript with the existing JavaScript ecosystem. I will post weekly updates about the progress of the project here. For more details about the project have a look at the ClojureScript GitHub &lt;a href='https://github.com/clojure/clojurescript/wiki/Google-Summer-of-Code-2015'&gt;wiki page&lt;/a&gt;.&lt;/em&gt;&lt;/p&gt;&lt;p&gt;Last week, David merged the first &lt;a href='https://github.com/clojure/clojurescript/commit/47947137127c9a724fafbeb17c5f7af7412809de'&gt;patch&lt;/a&gt; for CommonJS support into the ClojureScript compiler. This is a good first step. Following, I will describe how you can try out the changes and include a CommonJS module into a ClojureScript project.&lt;/p&gt;&lt;h4&gt;&lt;a name=&quot;build&amp;#95;clojurescript&quot;&gt;&lt;/a&gt;Build ClojureScript&lt;/h4&gt;&lt;p&gt;For this to work, we need to compile our own ClojureScript compiler as the most recent version &lt;code&gt;0.0-3308&lt;/code&gt; doesn't include the changes yet. So go ahead and clone the ClojureScript repository:&lt;/p&gt;&lt;pre&gt;&lt;code&gt;$ git clone git@github.com:clojure/clojurescript.git
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;Now we need to build a version of the ClojureScript compiler. I will describe two ways to do this. Which way you choose depends on your ClojureScript project setup.&lt;/p&gt;&lt;h5&gt;&lt;a name=&quot;without&amp;#95;a&amp;#95;build&amp;#95;tool&quot;&gt;&lt;/a&gt;Without a build tool&lt;/h5&gt;&lt;p&gt;For a simple setup follow the ClojureScript &lt;a href='https://github.com/clojure/clojurescript/wiki/Quick-Start'&gt;Quick Start tutorial&lt;/a&gt;, but instead of downloading an existing stand-alone ClojureScript JAR, we will build our own. Change to your ClojureScript directory that you just cloned and build the JAR using an existing script:&lt;/p&gt;&lt;pre&gt;&lt;code&gt;$ ./script/uberjar
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;This will create a stand-alone jar in the &lt;code&gt;target&lt;/code&gt; directory under the name &lt;code&gt;cljs.jar&lt;/code&gt;. Now go to your project directory and copy the JAR:&lt;/p&gt;&lt;pre&gt;&lt;code&gt;$ cp CLJS&amp;#95;PATH/target/cljs.jar .
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;Assuming you followed the ClojureScript Quick Start tutorial and your build script is located under &lt;code&gt;build.clj&lt;/code&gt; you can build your project with:&lt;/p&gt;&lt;pre&gt;&lt;code&gt;$ java -cp cljs.jar:src clojure.main build.clj
&lt;/code&gt;&lt;/pre&gt;&lt;h5&gt;&lt;a name=&quot;with&amp;#95;a&amp;#95;build&amp;#95;tool&quot;&gt;&lt;/a&gt;With a build tool&lt;/h5&gt;&lt;p&gt;If you are using a build tool, you need to install a new version of ClojureScript into your local maven repository. For this, change to the ClojureScript repository you just cloned and execute the following script:&lt;/p&gt;&lt;pre&gt;&lt;code&gt;$ ./script/build
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;This should install a new version of ClojureScript. To get the version, check the output of the script, e.g. it should say something similar to this:&lt;/p&gt;&lt;pre&gt;&lt;code&gt;&amp;#91;INFO&amp;#93; Installing /Users/marianeise/Documents/development/clojurescript/target/clojurescript-0.0-3332.jar to /Users/marianeise/.m2/repository/org/clojure/clojurescript/0.0-3332/clojurescript-0.0-3332.jar
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;In this case, the version you would need to use is &lt;code&gt;0.0-3332&lt;/code&gt;.&lt;/p&gt;&lt;h4&gt;&lt;a name=&quot;compiler&amp;#95;options&quot;&gt;&lt;/a&gt;Compiler Options&lt;/h4&gt;&lt;p&gt;To support JavaScript modules we added the compiler option &lt;code&gt;:module-type&lt;/code&gt; for foreign libraries, which later on should support the values &lt;code&gt;:commonjs&lt;/code&gt;, &lt;code&gt;:amd&lt;/code&gt; and &lt;code&gt;:es6&lt;/code&gt;. For now, only &lt;code&gt;:commonjs&lt;/code&gt; is supported. You can include a CommonJS module as follows:&lt;/p&gt;&lt;pre&gt;&lt;code&gt;:foreign-libs &amp;#91;{:file &amp;quot;libs/greeting.js&amp;quot;
                :provides &amp;#91;&amp;quot;greeting&amp;quot;&amp;#93;
                :module-type :commonjs}&amp;#93;

&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;If your CommonJS module depends on other modules, you also need to add them, e.g.:&lt;/p&gt;&lt;pre&gt;&lt;code&gt;:foreign-libs &amp;#91;{:file &amp;quot;libs/greeting.js&amp;quot;
                :provides &amp;#91;&amp;quot;greeting&amp;quot;&amp;#93;
                :module-type :commonjs}
               {:file &amp;quot;libs/german.js&amp;quot;
                :provides &amp;#91;&amp;quot;german&amp;quot;&amp;#93;
                :module-type :commonjs}&amp;#93;
&lt;/code&gt;&lt;/pre&gt;&lt;h4&gt;&lt;a name=&quot;known&amp;#95;issues&quot;&gt;&lt;/a&gt;Known issues&lt;/h4&gt;&lt;p&gt;This feature is still &quot;work in progress&quot;. You can read about known issues here:&lt;/p&gt;&lt;ul&gt;&lt;li&gt;&lt;a href='http://dev.clojure.org/jira/browse/CLJS-1312'&gt;CommonJS support: Properly convert JS lib idiom for adding module support for multiple specifications&lt;/a&gt;&lt;/li&gt;&lt;li&gt;&lt;a href='http://dev.clojure.org/jira/browse/CLJS-1311'&gt;Improve error reporting when converting CommonJS modules&lt;/a&gt;&lt;/li&gt;&lt;/ul&gt;
</description>
<pubDate>
Mon, 15 Jun 2015 00:00:00 +1200
</pubDate>
<author>
Maria Neise
</author>
</item>
<item>
<guid>
http://mneise.github.io/posts/2015-06-08-week-2.html
</guid>
<link>
http://mneise.github.io/posts/2015-06-08-week-2.html
</link>
<title>
GSoC: Week 2 - ClojureScript's JS dependency index
</title>
<description>
&lt;p&gt;&lt;em&gt;I have been accepted to this years Google's Summer of Code to work on ClojureScript. The goal of my project is to improve the integration of ClojureScript with the existing JavaScript ecosystem. I will post weekly updates about the progress of the project here. For more details about the project have a look at the ClojureScript GitHub &lt;a href='https://github.com/clojure/clojurescript/wiki/Google-Summer-of-Code-2015'&gt;wiki page&lt;/a&gt;.&lt;/em&gt;&lt;/p&gt;&lt;p&gt;During week 2 we continued to focus on adding support for CommonJS libraries to ClojureScript. An integral part of the CommonJS specification is the &lt;code&gt;require&lt;/code&gt; function. The &lt;code&gt;require&lt;/code&gt; function is used to import functionality that has been exported by other modules. In the following I will try to describe what we need to consider when adding support for CommonJS modules which depend on other modules and how a possible solution could look like.&lt;/p&gt;&lt;p&gt;Let's assume we have the following two CommonJS modules:&lt;/p&gt;&lt;pre&gt;&lt;code class=&quot;javascript&quot;&gt;// libs/german.js
exports.hello = function&amp;#40;&amp;#41; {
    return &amp;quot;Hallo&amp;quot;;
};
&lt;/code&gt;&lt;/pre&gt;&lt;pre&gt;&lt;code class=&quot;javascript&quot;&gt;// libs/greeting.js
var german = require&amp;#40;&amp;quot;german&amp;quot;&amp;#41;;

exports.hello = function&amp;#40;name&amp;#41; {
    return german.hello&amp;#40;&amp;#41; + &amp;quot;, &amp;quot; + name;
};
&lt;/code&gt;&lt;/pre&gt;In the example above, we are importing the functionality that is provided by the &lt;code&gt;german&lt;/code&gt; module into the &lt;code&gt;greeting&lt;/code&gt; module. This means, if we would like to use the &lt;code&gt;greeting&lt;/code&gt; module in our ClojureScript project we will need to add both modules to the ClojureScript compiler options, so that the compiler can find the sources.&lt;pre&gt;&lt;code class=&quot;clojure&quot;&gt;&amp;#40;require 'cljs.build.api&amp;#41;

&amp;#40;cljs.build.api/build &amp;quot;src&amp;quot;
  {:main 'hello-world.core
   :output-to &amp;quot;out/main.js&amp;quot;
   :foreign-libs
     &amp;#91;{:file &amp;quot;libs/greeting.js&amp;quot;
       :provides &amp;#91;&amp;quot;greeting&amp;quot;&amp;#93;
       :module-type :commonjs}
      {:file &amp;quot;libs/german.js&amp;quot;
       :provides &amp;#91;&amp;quot;german&amp;quot;&amp;#93;
       :module-type :commonjs}&amp;#93;}&amp;#41;
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;In general, to be able to resolve and check JavaScript dependencies for a ClojureScript namespace, the ClojureScript compiler first constructs a JavaScript dependency index using the compiler options. This index not only contains the dependencies that are passed via the compiler options &lt;code&gt;:foreign-libs&lt;/code&gt; and &lt;code&gt;:libs&lt;/code&gt;, but also contains entries for the modules that are listed in &lt;a href='https://github.com/google/closure-library/blob/master/closure/goog/deps.js'&gt;goog/deps.js&lt;/a&gt;. The dependency index is indexed by namespaces and each entry contains a map with more information about that namespace, e.g. the location of the file or which other modules this namespace requires. For example, for our example above we would like to have entries in the dependency index similar to the following:&lt;/p&gt;&lt;pre&gt;&lt;code class=&quot;clojure&quot;&gt;{...
 greeting
   {:file libs/greeting.js
    :provides &amp;#91;greeting&amp;#93;
    :foreign true
    :url #object&amp;#91;java.net.URL 0x523424b5 file:/Users/marianeise/Documents/development/hello&amp;#95;world/libs/greeting.js&amp;#93;
    :module-type :commonjs
    :requires &amp;#91;german&amp;#93;}
 german
   {:file libs/german.js
    :provides &amp;#91;german&amp;#93;
    :foreign true
    :url #object&amp;#91;java.net.URL 0x523424b5 file:/Users/marianeise/Documents/development/hello&amp;#95;world/libs/german.js&amp;#93;
    :module-type :commonjs
    :requires &amp;#91;&amp;#93;}
...}
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;In the example above, we can see that the map for the &lt;code&gt;greeting&lt;/code&gt; module contains an entry under the &lt;code&gt;:requires&lt;/code&gt; key which holds a vector with all the namespaces that are required. To create this entry, we would need to be able to parse calls to the &lt;code&gt;require&lt;/code&gt; function from CommonJS modules and later also for AMD and ECMAScript 6 modules, which both use a different syntax to import modules. Instead of writing parsers for three different module specifications, we've decided to go with a different approach for now that uses existing functionality. The ClojureScript compiler already includes the functionality to parse the &lt;code&gt;provide&lt;/code&gt; and &lt;code&gt;require&lt;/code&gt; statements from Google Closure-compatible JavaScript files which are included into the project using the &lt;code&gt;:libs&lt;/code&gt; option. As mentioned in my previous post, we are using the Google Closure compiler to convert JavaScript modules to Google Closure modules to be able to include them into a ClojureScript project. This means, before creating the dependency index we convert the CommonJS modules into Google Closure modules and write them to disk.&lt;/p&gt;&lt;pre&gt;&lt;code class=&quot;javascript&quot;&gt;// out/german.js
goog.provide&amp;#40;&amp;quot;module$libs$german&amp;quot;&amp;#41;;
var module$libs$german = {};
module$libs$german.hello = function&amp;#40;&amp;#41; {
  return &amp;quot;Hallo&amp;quot;;
};
&lt;/code&gt;&lt;/pre&gt;&lt;pre&gt;&lt;code class=&quot;javascript&quot;&gt;// out/greeting.js
goog.provide&amp;#40;&amp;quot;module$libs$greeting&amp;quot;&amp;#41;;
var module$libs$greeting = {};
goog.require&amp;#40;&amp;quot;module$libs$german&amp;quot;&amp;#41;;
var german$$module$libs$greeting = module$libs$german;
module$libs$greeting.hello = function&amp;#40;name&amp;#41; {
  return german$$module$libs$greeting.hello&amp;#40;&amp;#41; + &amp;quot;, &amp;quot; + name;
};
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;We now have Google Closure-compatible JavaScript modules and can update the compiler options to look similar to the following:&lt;/p&gt;&lt;pre&gt;&lt;code class=&quot;clojure&quot;&gt;{:output-to &amp;quot;out/main.js&amp;quot;
 :foreign-libs &amp;#91;&amp;#93;
 :libs &amp;#91;&amp;quot;out/greeting.js&amp;quot; &amp;quot;out/german.js&amp;quot;&amp;#93;
 :main 'hello-world.core}
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;Instead of passing the modules as foreign libraries we now pass them via the &lt;code&gt;:libs&lt;/code&gt; compiler option to build the dependency index. Note that also the path to the files has changed to point to the converted version of the modules. This means, the modules will be treated as &quot;normal&quot; Google Closure-compatible JavaScript files by the compiler and the imports for our &lt;code&gt;greeting&lt;/code&gt; module will be extracted successfully. The entries in the JavaScript dependency index will look similar to the following:&lt;/p&gt;&lt;pre&gt;&lt;code class=&quot;clojure&quot;&gt;{...
 module$libs$greeting
   {:requires &amp;#91;module$libs$german&amp;#93;
    :provides &amp;#91;module$libs$greeting&amp;#93;
    :url #object&amp;#91;java.net.URL 0x4a067c25 file:/Users/marianeise/Documents/development/hello&amp;#95;world/out/greeting.js&amp;#93;
    :closure-lib true
    :lib-path out/greeting.js}
 module$libs$german
   {:requires &amp;#91;&amp;#93;
    :provides &amp;#91;module$libs$german&amp;#93;
    :url #object&amp;#91;java.net.URL 0xa1217f9 file:/Users/marianeise/Documents/development/hello&amp;#95;world/out/german.js&amp;#93;
    :closure-lib true
    :lib-path out/german.js}
...}
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;To learn more about the dependency index, have a look at &lt;a href='https://github.com/clojure/clojurescript/blob/master/src/main/clojure/cljs/js&amp;#95;deps.clj'&gt;js&amp;#95;deps.clj&lt;/a&gt; in the ClojureScript project. To see the current progress for this project, have a look at the GitHub &lt;a href='https://github.com/mneise/clojurescript/tree/CLJS-1092'&gt;branch&lt;/a&gt;.&lt;/p&gt;
</description>
<pubDate>
Mon, 08 Jun 2015 00:00:00 +1200
</pubDate>
<author>
Maria Neise
</author>
</item>
<item>
<guid>
http://mneise.github.io/posts/2015-06-02-week-1.html
</guid>
<link>
http://mneise.github.io/posts/2015-06-02-week-1.html
</link>
<title>
GSoC: Week 1 - Converting JavaScript modules to Google Closure modules
</title>
<description>
&lt;p&gt;&lt;em&gt;I have been accepted to this years Google's Summer of Code to work on ClojureScript. The goal of my project is to improve the integration of ClojureScript with the existing JavaScript ecosystem. I will post weekly updates about the progress of the project here. For more details about the project have a look at the ClojureScript GitHub &lt;a href='https://github.com/clojure/clojurescript/wiki/Google-Summer-of-Code-2015'&gt;wiki page&lt;/a&gt;.&lt;/em&gt;&lt;/p&gt;&lt;p&gt;Last week was the first week of my Google's Summer of Code project. The first part of the project that I will be working on is adding JavaScript module support to ClojureScript, meaning that CommonJS, AMD and ECMAScript 6 modules can be included into a ClojureScript project. For this, we will be using functionality that is already included in the Google Closure compiler. The Google Closure compiler has the classes &lt;code&gt;ProcessCommonJSModules&lt;/code&gt; and &lt;code&gt;ProcessEs6Modules&lt;/code&gt;, which each convert either a CommonJS or ECMAScript 6 module into a Google Closure module. To be able to use those two classes directly from within the ClojureScript compiler, we needed to make the classes and its constructors public. Luckily, our &lt;a href='https://github.com/google/closure-compiler/pull/952'&gt;pull request&lt;/a&gt; to the Google Closure compiler project got accepted and our changes should be included in the next release of the project. With those changes in place, I started off by working on including a CommonJS module into a ClojureScript project. Following, I will try to describe which functionality we will need to add to the ClojurScript compiler so that users can include a CommonJS module without modifying it.&lt;/p&gt;&lt;p&gt;Assume we have the following simple CommonJS module in &lt;code&gt;libs/greeting.js&lt;/code&gt;:&lt;/p&gt;&lt;pre&gt;&lt;code class=&quot;javascript&quot;&gt;exports.hello = function&amp;#40;name&amp;#41; {
    return &amp;quot;Hello, &amp;quot; + name;
};
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;We can include this module as a foreign library. To specify the module type, we will be adding a new compiler option called &lt;code&gt;module-type&lt;/code&gt;, which can have the values &lt;code&gt;:commonjs&lt;/code&gt;, &lt;code&gt;:es6&lt;/code&gt; and &lt;code&gt;:amd&lt;/code&gt;.&lt;/p&gt;&lt;pre&gt;&lt;code class=&quot;clojure&quot;&gt;&amp;#40;require 'cljs.build.api&amp;#41;

&amp;#40;cljs.build.api/build &amp;quot;src&amp;quot;
                      {:main 'hello-world.core
                       :output-to &amp;quot;out/main.js&amp;quot;
                       :foreign-libs &amp;#91;{:file &amp;quot;libs/greeting.js&amp;quot;
                                       :provides &amp;#91;&amp;quot;greeting&amp;quot;&amp;#93;
                                       :module-type :commonjs}&amp;#93;}&amp;#41;
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;To be able to use the functionality provided by the module, we need to require it into our namespace with the same name that we used in the &lt;code&gt;provides&lt;/code&gt; compiler option for the module.&lt;/p&gt;&lt;pre&gt;&lt;code class=&quot;clojure&quot;&gt;&amp;#40;ns hello-world.core
  &amp;#40;:require &amp;#91;greeting&amp;#93;&amp;#41;&amp;#41;

&amp;#40;enable-console-print!&amp;#41;

&amp;#40;println &amp;#40;.hello js/greeting &amp;quot;World!&amp;quot;&amp;#41;&amp;#41;
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;If the ClojureScript compiler would try to handle the module the same way as any other foreign library, we would get the following errors:&lt;/p&gt;&lt;p&gt;&lt;img src=&quot;/images/week1-error1.png&quot; alt=&quot;error 1&quot; /&gt;&lt;/p&gt;&lt;p&gt;We are getting the first error, because the Google Closure dependency management system doesn't implement the CommonJS specification. To get rid of the first error, we need to convert the CommonJS module into a form that is understood by the Google Closure dependency management system and can be used in combination with other Google Closure modules. For this task, we can use the &lt;code&gt;ProcessCommonJSModules&lt;/code&gt; class. Instead of wrapping everything in a function it adds a filename based prefix to the global variables and adds a &lt;code&gt;goog.provide&lt;/code&gt; statement.&lt;/p&gt;&lt;pre&gt;&lt;code class=&quot;javascript&quot;&gt;goog.provide&amp;#40;&amp;quot;module$libs$greeting&amp;quot;&amp;#41;;
var module$libs$greeting = {};
module$libs$greeting.hello = function&amp;#40;name&amp;#41; {
  return &amp;quot;Hello, &amp;quot; + name;
};
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;Converting the CommonJS module helps us to get rid of the &lt;code&gt;exports&lt;/code&gt; error, but we are still left with the &lt;code&gt;greeting is not defined&lt;/code&gt; error. If you have a look at the JavaScript that the compiler emitted, you can see that we are requiring the module as &lt;code&gt;greeting&lt;/code&gt; and later use the &lt;code&gt;greeting&lt;/code&gt; object to call the &lt;code&gt;hello&lt;/code&gt; function on.&lt;/p&gt;&lt;pre&gt;&lt;code class=&quot;javascript&quot;&gt;// Compiled by ClojureScript 0.0-0000 {}
goog.provide&amp;#40;'hello&amp;#95;world.core'&amp;#41;;
goog.require&amp;#40;'cljs.core'&amp;#41;;
goog.require&amp;#40;'greeting'&amp;#41;;
cljs.core.enable&amp;#95;console&amp;#95;print&amp;#95;BANG&amp;#95;.call&amp;#40;null&amp;#41;;
cljs.core.println.call&amp;#40;null,greeting.hello&amp;#40;&amp;quot;World!&amp;quot;&amp;#41;&amp;#41;;

//# sourceMappingURL=core.js.map
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;Looking at the rewritten module code we can see that we should be using &lt;code&gt;module$libs$greeting&lt;/code&gt; to refer to the module instead. This means, in the ClojureScript compiler whenever we see a reference to the module using the &quot;old&quot; name (&lt;code&gt;greeting&lt;/code&gt;) while emitting the JavaScript we need to replace it with the &quot;new&quot; name (&lt;code&gt;module$libs$greeting&lt;/code&gt;).&lt;/p&gt;&lt;pre&gt;&lt;code class=&quot;javascript&quot;&gt;// Compiled by ClojureScript 0.0-0000 {}
goog.provide&amp;#40;'hello&amp;#95;world.core'&amp;#41;;
goog.require&amp;#40;'cljs.core'&amp;#41;;
goog.require&amp;#40;'module$libs$greeting'&amp;#41;;
cljs.core.enable&amp;#95;console&amp;#95;print&amp;#95;BANG&amp;#95;.call&amp;#40;null&amp;#41;;
cljs.core.println.call&amp;#40;null,module$libs$greeting.hello&amp;#40;&amp;quot;World!&amp;quot;&amp;#41;&amp;#41;;

//# sourceMappingURL=core.js.map
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;Finally, we get our &lt;code&gt;Hello, World!&lt;/code&gt;.&lt;/p&gt;&lt;p&gt;&lt;img src=&quot;/images/week1-hello.png&quot; alt=&quot;Hello, World!&quot; /&gt;&lt;/p&gt;&lt;p&gt;To see the current progress, have a look at the GitHub &lt;a href='https://github.com/mneise/clojurescript/tree/CLJS-1092'&gt;branch&lt;/a&gt;.&lt;/p&gt;
</description>
<pubDate>
Tue, 02 Jun 2015 00:00:00 +1200
</pubDate>
<author>
Maria Neise
</author>
</item>
</channel>
</rss>
