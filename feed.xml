<?xml version='1.0' encoding='UTF-8'?>
<rss version='2.0' xmlns:atom='http://www.w3.org/2005/Atom'>
<channel>
<atom:link href='http://mneise.github.io' rel='self' type='application/rss+xml'/>
<generator>
clj-rss
</generator>
<title>
My Blog
</title>
<link>
http://mneise.github.io
</link>
<description>
Some updates and thoughts
</description>
<lastBuildDate>
Tue, 30 Jun 2015 00:55:18 +0200
</lastBuildDate>
<author>
Maria Neise
</author>
<item>
<guid>
http://mneise.github.io/posts/2015-06-29-week-5.html
</guid>
<link>
http://mneise.github.io/posts/2015-06-29-week-5.html
</link>
<title>
GSoC: Week 5
</title>
<description>
&lt;p&gt;&lt;em&gt;I have been accepted to this years Google's Summer of Code to work on ClojureScript. The goal of my project is to improve the integration of ClojureScript with the existing JavaScript ecosystem. I will post weekly updates about the progress of the project here. For more details about the project have a look at the ClojureScript GitHub &lt;a href='https://github.com/clojure/clojurescript/wiki/Google-Summer-of-Code-2015'&gt;wiki page&lt;/a&gt;.&lt;/em&gt;&lt;/p&gt;&lt;p&gt;The Google Summer of Code student midterm evaluations are due this week on 3 July 2015 at 19:00 UTC, so I will use this post to write about my experience with the Google Summer of Code program, reflect on the previous 5 weeks and talk about the tasks for the next following 8 weeks.&lt;/p&gt;&lt;p&gt;The Google Summer of Code program has been a great opportunity for me to start contributing to open source and to connect with the Clojure community. Many great projects have come out of it, such as &lt;a href='https://twitter.com/ambrosebs'&gt;Ambrose Bonnaire-Sergeant's&lt;/a&gt; &lt;a href='http://typedclojure.org/'&gt;Typed Clojure&lt;/a&gt;, and students as well as organizations are benefiting from GSoC. As much as I value the GSoC program, there is still room for improvement. In particular, communication between GSoC students is not promoted by the program organizers which is likely one reason for the lack of community between GSoC students.&lt;/p&gt;&lt;p&gt;Then again, the Clojure and ClojureScript community has been really welcoming and helpful. Many people seem to be excited about this project and I've only had positive interactions with other Clojurians so far. My mentor for this project, &lt;a href='https://twitter.com/swannodette'&gt;David Nolen&lt;/a&gt;, has been more than helpful, very responsive and has been doing a lot to promote this GSoC project. Also, a big thank you to &lt;a href='https://twitter.com/mfikes'&gt;Mike Fikes&lt;/a&gt;, who has been trying out the CommonJS support in &lt;a href='http://blog.fikesfarm.com/posts/2015-06-17-commonjs-libs-in-ambly.html'&gt;Ambly&lt;/a&gt; and has given me very valuable feedback.&lt;/p&gt;&lt;p&gt;Regarding the project itself, we are making good progress and are sticking to the estimated schedule. We've added support for CommonJS, AMD and ECMAScript 2015 to ClojureScript and submitted two pull requests to the Google Closure compiler. For the following weeks, we will continue to improve the JavaScript module support and will work on generating externs for foreign libraries. So stay tuned, there is more to come ;)&lt;/p&gt;
</description>
<pubDate>
Mon, 29 Jun 2015 00:00:00 +0200
</pubDate>
<author>
Maria Neise
</author>
</item>
<item>
<guid>
http://mneise.github.io/posts/2015-06-22-week-4.html
</guid>
<link>
http://mneise.github.io/posts/2015-06-22-week-4.html
</link>
<title>
GSoC: Week 4
</title>
<description>
&lt;p&gt;&lt;em&gt;I have been accepted to this years Google's Summer of Code to work on ClojureScript. The goal of my project is to improve the integration of ClojureScript with the existing JavaScript ecosystem. I will post weekly updates about the progress of the project here. For more details about the project have a look at the ClojureScript GitHub &lt;a href='https://github.com/clojure/clojurescript/wiki/Google-Summer-of-Code-2015'&gt;wiki page&lt;/a&gt;.&lt;/em&gt;&lt;/p&gt;&lt;p&gt;Last week, we made further progress in adding JavaScript module support to ClojureScript. David merged two patches, one for &lt;a href='https://github.com/clojure/clojurescript/commit/87f39511a54d7b91ae86f581fda90f280f985816'&gt;AMD module support&lt;/a&gt; and the other for &lt;a href='https://github.com/clojure/clojurescript/commit/ac0b169cb082bd2ff4ac917274cb91628adba947'&gt;ECMAScript 2015 module support&lt;/a&gt;. In this post, I will describe how to use AMD and ECMAScript 2015 modules in a ClojureScript project.&lt;/p&gt;&lt;h4&gt;&lt;a name=&quot;amd&quot;&gt;&lt;/a&gt;AMD&lt;/h4&gt;&lt;p&gt;Adding support for AMD is very similar to adding support for CommonJS. The only difference is that we first rewrite an AMD module to a CommonJS module before converting it to a Google Closure module. Both can be done with the Google Closure compiler. Currently, the Google Closure compiler supports the following AMD &lt;code&gt;define&lt;/code&gt; signatures:&lt;/p&gt;&lt;pre&gt;&lt;code&gt;define&amp;#40;function&amp;#40;&amp;#41; ...&amp;#41;
define&amp;#40;OBJECT&amp;#95;LITERAL&amp;#41;
define&amp;#40;&amp;#91;'dep', 'dep1'&amp;#93;, function&amp;#40;d0, d2, &amp;#91;exports, module&amp;#93;&amp;#41; ...&amp;#41;
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;For example, the following is an AMD module that can be processed by the Google Closure compiler:&lt;/p&gt;&lt;pre&gt;&lt;code class=&quot;javascript&quot;&gt;// greeting.js
define&amp;#40;function &amp;#40;&amp;#41; {
    return {
        hello: function &amp;#40;name&amp;#41; {
            return &amp;quot;Hello, &amp;quot; + name;
        }
    };
}&amp;#41;;
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;To be able to include this module, we need to build our own version of the Google Closure compiler and the ClojureScript compiler. The reason for this is that we are using the package private class &lt;code&gt;TransformAMDToCJModules&lt;/code&gt; from the Google Closure compiler to rewrite an AMD module to a CommonJS module. We need to make the class and its constructor public to be able to use this functionality. We have already submitted a &lt;a href='https://github.com/google/closure-compiler/pull/1012'&gt;patch&lt;/a&gt; for this and the change will hopefully be merged and included in the next release of the Google Closure compiler. But for now, clone the Google Closure compiler repository, build it and install it to your local maven repository as follows:&lt;/p&gt;&lt;pre&gt;&lt;code&gt;$ git clone git@github.com:google/closure-compiler.git
$ cd closure-compiler
$ ant jar
$ mvn install:install-file -Dfile=build/compiler.jar -DgroupId=com.google.javascript -DartifactId=closure-compiler -Dversion=v20150622-SNAPSHOT -Dpackaging=jar
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;Before building a new version of the ClojureScript compiler (see the previous &lt;a href='http://mneise.github.io/posts/2015-06-15-week-3.html'&gt;post&lt;/a&gt;) change the version of the Google Closure compiler in ClojureScript's &lt;code&gt;project.clj&lt;/code&gt; file to the same version you used to install the Google Closure compiler JAR to your local maven repository, for example:&lt;/p&gt;&lt;pre&gt;&lt;code class=&quot;clojure&quot;&gt;&amp;#91;com.google.javascript/closure-compiler &amp;quot;v20150622-SNAPSHOT&amp;quot;&amp;#93;
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;Finally, include the AMD module with the new compiler option &lt;code&gt;module-type&lt;/code&gt; and the value &lt;code&gt;:amd&lt;/code&gt;:&lt;/p&gt;&lt;pre&gt;&lt;code class=&quot;clojure&quot;&gt;:foreign-libs &amp;#91;{:file &amp;quot;libs/greeting.js&amp;quot;
                :provides &amp;#91;&amp;quot;greeting&amp;quot;&amp;#93;
                :module-type :amd}&amp;#93;
&lt;/code&gt;&lt;/pre&gt;&lt;h4&gt;&lt;a name=&quot;ecmascript&amp;#95;2015&quot;&gt;&lt;/a&gt;ECMAScript 2015&lt;/h4&gt;&lt;p&gt;The Google Closure compiler includes the functionality to transpile from ECMAScript 2015 to a lower version. We are using this functionality to add support for ECMAScript 2015 modules and are converting ECMAScript 2015 modules to Google Closure ECMAScript 5 modules.&lt;/p&gt;&lt;pre&gt;&lt;code class=&quot;javascript&quot;&gt;// greeting.js
export function hello&amp;#40;name&amp;#41; {
    return &amp;quot;Hello, &amp;quot; + name;
};
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;To include the above module, we need to build a recent version of the ClojureScript compiler (see the previous &lt;a href='http://mneise.github.io/posts/2015-06-15-week-3.html'&gt;post&lt;/a&gt;) and use the new compiler option &lt;code&gt;module-type&lt;/code&gt; with the value &lt;code&gt;:es6&lt;/code&gt;:&lt;/p&gt;&lt;pre&gt;&lt;code class=&quot;clojure&quot;&gt;:foreign-libs &amp;#91;{:file &amp;quot;libs/greeting.js&amp;quot;
                :provides &amp;#91;&amp;quot;greeting&amp;quot;&amp;#93;
                :module-type :es6}&amp;#93;
&lt;/code&gt;&lt;/pre&gt;
</description>
<pubDate>
Mon, 22 Jun 2015 00:00:00 +0200
</pubDate>
<author>
Maria Neise
</author>
</item>
<item>
<guid>
http://mneise.github.io/posts/2015-06-15-week-3.html
</guid>
<link>
http://mneise.github.io/posts/2015-06-15-week-3.html
</link>
<title>
GSoC: Week 3
</title>
<description>
&lt;p&gt;&lt;em&gt;I have been accepted to this years Google's Summer of Code to work on ClojureScript. The goal of my project is to improve the integration of ClojureScript with the existing JavaScript ecosystem. I will post weekly updates about the progress of the project here. For more details about the project have a look at the ClojureScript GitHub &lt;a href='https://github.com/clojure/clojurescript/wiki/Google-Summer-of-Code-2015'&gt;wiki page&lt;/a&gt;.&lt;/em&gt;&lt;/p&gt;&lt;p&gt;Last week, David merged the first &lt;a href='https://github.com/clojure/clojurescript/commit/47947137127c9a724fafbeb17c5f7af7412809de'&gt;patch&lt;/a&gt; for CommonJS support into the ClojureScript compiler. This is a good first step. Following, I will describe how you can try out the changes and include a CommonJS module into a ClojureScript project.&lt;/p&gt;&lt;h4&gt;&lt;a name=&quot;build&amp;#95;clojurescript&quot;&gt;&lt;/a&gt;Build ClojureScript&lt;/h4&gt;&lt;p&gt;For this to work, we need to compile our own ClojureScript compiler as the most recent version &lt;code&gt;0.0-3308&lt;/code&gt; doesn't include the changes yet. So go ahead and clone the ClojureScript repository:&lt;/p&gt;&lt;pre&gt;&lt;code&gt;$ git clone git@github.com:clojure/clojurescript.git
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;Now we need to build a version of the ClojureScript compiler. I will describe two ways to do this. Which way you choose depends on your ClojureScript project setup.&lt;/p&gt;&lt;h5&gt;&lt;a name=&quot;without&amp;#95;a&amp;#95;build&amp;#95;tool&quot;&gt;&lt;/a&gt;Without a build tool&lt;/h5&gt;&lt;p&gt;For a simple setup follow the ClojureScript &lt;a href='https://github.com/clojure/clojurescript/wiki/Quick-Start'&gt;Quick Start tutorial&lt;/a&gt;, but instead of downloading an existing stand-alone ClojureScript JAR, we will build our own. Change to your ClojureScript directory that you just cloned and build the JAR using an existing script:&lt;/p&gt;&lt;pre&gt;&lt;code&gt;$ ./script/uberjar
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;This will create a stand-alone jar in the &lt;code&gt;target&lt;/code&gt; directory under the name &lt;code&gt;cljs.jar&lt;/code&gt;. Now go to your project directory and copy the JAR:&lt;/p&gt;&lt;pre&gt;&lt;code&gt;$ cp CLJS&amp;#95;PATH/target/cljs.jar .
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;Assuming you followed the ClojureScript Quick Start tutorial and your build script is located under &lt;code&gt;build.clj&lt;/code&gt; you can build your project with:&lt;/p&gt;&lt;pre&gt;&lt;code&gt;$ java -cp cljs.jar:src clojure.main build.clj
&lt;/code&gt;&lt;/pre&gt;&lt;h5&gt;&lt;a name=&quot;with&amp;#95;a&amp;#95;build&amp;#95;tool&quot;&gt;&lt;/a&gt;With a build tool&lt;/h5&gt;&lt;p&gt;If you are using a build tool, you need to install a new version of ClojureScript into your local maven repository. For this, change to the ClojureScript repository you just cloned and execute the following script:&lt;/p&gt;&lt;pre&gt;&lt;code&gt;$ ./script/build
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;This should install a new version of ClojureScript. To get the version, check the output of the script, e.g. it should say something similar to this:&lt;/p&gt;&lt;pre&gt;&lt;code&gt;&amp;#91;INFO&amp;#93; Installing /Users/marianeise/Documents/development/clojurescript/target/clojurescript-0.0-3332.jar to /Users/marianeise/.m2/repository/org/clojure/clojurescript/0.0-3332/clojurescript-0.0-3332.jar
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;In this case, the version you would need to use is &lt;code&gt;0.0-3332&lt;/code&gt;.&lt;/p&gt;&lt;h4&gt;&lt;a name=&quot;compiler&amp;#95;options&quot;&gt;&lt;/a&gt;Compiler Options&lt;/h4&gt;&lt;p&gt;To support JavaScript modules we added the compiler option &lt;code&gt;:module-type&lt;/code&gt; for foreign libraries, which later on should support the values &lt;code&gt;:commonjs&lt;/code&gt;, &lt;code&gt;:amd&lt;/code&gt; and &lt;code&gt;:es6&lt;/code&gt;. For now, only &lt;code&gt;:commonjs&lt;/code&gt; is supported. You can include a CommonJS module as follows:&lt;/p&gt;&lt;pre&gt;&lt;code&gt;:foreign-libs &amp;#91;{:file &amp;quot;libs/greeting.js&amp;quot;
                :provides &amp;#91;&amp;quot;greeting&amp;quot;&amp;#93;
                :module-type :commonjs}&amp;#93;

&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;If your CommonJS module depends on other modules, you also need to add them, e.g.:&lt;/p&gt;&lt;pre&gt;&lt;code&gt;:foreign-libs &amp;#91;{:file &amp;quot;libs/greeting.js&amp;quot;
                :provides &amp;#91;&amp;quot;greeting&amp;quot;&amp;#93;
                :module-type :commonjs}
               {:file &amp;quot;libs/german.js&amp;quot;
                :provides &amp;#91;&amp;quot;german&amp;quot;&amp;#93;
                :module-type :commonjs}&amp;#93;
&lt;/code&gt;&lt;/pre&gt;&lt;h4&gt;&lt;a name=&quot;known&amp;#95;issues&quot;&gt;&lt;/a&gt;Known issues&lt;/h4&gt;&lt;p&gt;This feature is still &quot;work in progress&quot;. You can read about known issues here:&lt;/p&gt;&lt;ul&gt;&lt;li&gt;&lt;a href='http://dev.clojure.org/jira/browse/CLJS-1312'&gt;CommonJS support: Properly convert JS lib idiom for adding module support for multiple specifications&lt;/a&gt;&lt;/li&gt;&lt;li&gt;&lt;a href='http://dev.clojure.org/jira/browse/CLJS-1311'&gt;Improve error reporting when converting CommonJS modules&lt;/a&gt;&lt;/li&gt;&lt;/ul&gt;
</description>
<pubDate>
Mon, 15 Jun 2015 00:00:00 +0200
</pubDate>
<author>
Maria Neise
</author>
</item>
<item>
<guid>
http://mneise.github.io/posts/2015-06-08-week-2.html
</guid>
<link>
http://mneise.github.io/posts/2015-06-08-week-2.html
</link>
<title>
GSoC: Week 2
</title>
<description>
&lt;p&gt;&lt;em&gt;I have been accepted to this years Google's Summer of Code to work on ClojureScript. The goal of my project is to improve the integration of ClojureScript with the existing JavaScript ecosystem. I will post weekly updates about the progress of the project here. For more details about the project have a look at the ClojureScript GitHub &lt;a href='https://github.com/clojure/clojurescript/wiki/Google-Summer-of-Code-2015'&gt;wiki page&lt;/a&gt;.&lt;/em&gt;&lt;/p&gt;&lt;p&gt;During week 2 we continued to focus on adding support for CommonJS libraries to ClojureScript. An integral part of the CommonJS specification is the &lt;code&gt;require&lt;/code&gt; function. The &lt;code&gt;require&lt;/code&gt; function is used to import functionality that has been exported by other modules. In the following I will try to describe what we need to consider when adding support for CommonJS modules which depend on other modules and how a possible solution could look like.&lt;/p&gt;&lt;p&gt;Let's assume we have the following two CommonJS modules:&lt;/p&gt;&lt;pre&gt;&lt;code class=&quot;javascript&quot;&gt;// libs/german.js
exports.hello = function&amp;#40;&amp;#41; {
    return &amp;quot;Hallo&amp;quot;;
};
&lt;/code&gt;&lt;/pre&gt;&lt;pre&gt;&lt;code class=&quot;javascript&quot;&gt;// libs/greeting.js
var german = require&amp;#40;&amp;quot;german&amp;quot;&amp;#41;;

exports.hello = function&amp;#40;name&amp;#41; {
    return german.hello&amp;#40;&amp;#41; + &amp;quot;, &amp;quot; + name;
};
&lt;/code&gt;&lt;/pre&gt;In the example above, we are importing the functionality that is provided by the &lt;code&gt;german&lt;/code&gt; module into the &lt;code&gt;greeting&lt;/code&gt; module. This means, if we would like to use the &lt;code&gt;greeting&lt;/code&gt; module in our ClojureScript project we will need to add both modules to the ClojureScript compiler options, so that the compiler can find the sources.&lt;pre&gt;&lt;code class=&quot;clojure&quot;&gt;&amp;#40;require 'cljs.build.api&amp;#41;

&amp;#40;cljs.build.api/build &amp;quot;src&amp;quot;
  {:main 'hello-world.core
   :output-to &amp;quot;out/main.js&amp;quot;
   :foreign-libs
     &amp;#91;{:file &amp;quot;libs/greeting.js&amp;quot;
       :provides &amp;#91;&amp;quot;greeting&amp;quot;&amp;#93;
       :module-type :commonjs}
      {:file &amp;quot;libs/german.js&amp;quot;
       :provides &amp;#91;&amp;quot;german&amp;quot;&amp;#93;
       :module-type :commonjs}&amp;#93;}&amp;#41;
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;In general, to be able to resolve and check JavaScript dependencies for a ClojureScript namespace, the ClojureScript compiler first constructs a JavaScript dependency index using the compiler options. This index not only contains the dependencies that are passed via the compiler options &lt;code&gt;:foreign-libs&lt;/code&gt; and &lt;code&gt;:libs&lt;/code&gt;, but also contains entries for the modules that are listed in &lt;a href='https://github.com/google/closure-library/blob/master/closure/goog/deps.js'&gt;goog/deps.js&lt;/a&gt;. The dependency index is indexed by namespaces and each entry contains a map with more information about that namespace, e.g. the location of the file or which other modules this namespace requires. For example, for our example above we would like to have entries in the dependency index similar to the following:&lt;/p&gt;&lt;pre&gt;&lt;code class=&quot;clojure&quot;&gt;{...
 greeting
   {:file libs/greeting.js
    :provides &amp;#91;greeting&amp;#93;
    :foreign true
    :url #object&amp;#91;java.net.URL 0x523424b5 file:/Users/marianeise/Documents/development/hello&amp;#95;world/libs/greeting.js&amp;#93;
    :module-type :commonjs
    :requires &amp;#91;german&amp;#93;}
 german
   {:file libs/german.js
    :provides &amp;#91;german&amp;#93;
    :foreign true
    :url #object&amp;#91;java.net.URL 0x523424b5 file:/Users/marianeise/Documents/development/hello&amp;#95;world/libs/german.js&amp;#93;
    :module-type :commonjs
    :requires &amp;#91;&amp;#93;}
...}
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;In the example above, we can see that the map for the &lt;code&gt;greeting&lt;/code&gt; module contains an entry under the &lt;code&gt;:requires&lt;/code&gt; key which holds a vector with all the namespaces that are required. To create this entry, we would need to be able to parse calls to the &lt;code&gt;require&lt;/code&gt; function from CommonJS modules and later also for AMD and ECMAScript 6 modules, which both use a different syntax to import modules. Instead of writing parsers for three different module specifications, we've decided to go with a different approach for now that uses existing functionality. The ClojureScript compiler already includes the functionality to parse the &lt;code&gt;provide&lt;/code&gt; and &lt;code&gt;require&lt;/code&gt; statements from Google Closure-compatible JavaScript files which are included into the project using the &lt;code&gt;:libs&lt;/code&gt; option. As mentioned in my previous post, we are using the Google Closure compiler to convert JavaScript modules to Google Closure modules to be able to include them into a ClojureScript project. This means, before creating the dependency index we convert the CommonJS modules into Google Closure modules and write them to disk.&lt;/p&gt;&lt;pre&gt;&lt;code class=&quot;javascript&quot;&gt;// out/german.js
goog.provide&amp;#40;&amp;quot;module$libs$german&amp;quot;&amp;#41;;
var module$libs$german = {};
module$libs$german.hello = function&amp;#40;&amp;#41; {
  return &amp;quot;Hallo&amp;quot;;
};
&lt;/code&gt;&lt;/pre&gt;&lt;pre&gt;&lt;code class=&quot;javascript&quot;&gt;// out/greeting.js
goog.provide&amp;#40;&amp;quot;module$libs$greeting&amp;quot;&amp;#41;;
var module$libs$greeting = {};
goog.require&amp;#40;&amp;quot;module$libs$german&amp;quot;&amp;#41;;
var german$$module$libs$greeting = module$libs$german;
module$libs$greeting.hello = function&amp;#40;name&amp;#41; {
  return german$$module$libs$greeting.hello&amp;#40;&amp;#41; + &amp;quot;, &amp;quot; + name;
};
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;We now have Google Closure-compatible JavaScript modules and can update the compiler options to look similar to the following:&lt;/p&gt;&lt;pre&gt;&lt;code class=&quot;clojure&quot;&gt;{:output-to &amp;quot;out/main.js&amp;quot;
 :foreign-libs &amp;#91;&amp;#93;
 :libs &amp;#91;&amp;quot;out/greeting.js&amp;quot; &amp;quot;out/german.js&amp;quot;&amp;#93;
 :main 'hello-world.core}
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;Instead of passing the modules as foreign libraries we now pass them via the &lt;code&gt;:libs&lt;/code&gt; compiler option to build the dependency index. Note that also the path to the files has changed to point to the converted version of the modules. This means, the modules will be treated as &quot;normal&quot; Google Closure-compatible JavaScript files by the compiler and the imports for our &lt;code&gt;greeting&lt;/code&gt; module will be extracted successfully. The entries in the JavaScript dependency index will look similar to the following:&lt;/p&gt;&lt;pre&gt;&lt;code class=&quot;clojure&quot;&gt;{...
 module$libs$greeting
   {:requires &amp;#91;module$libs$german&amp;#93;
    :provides &amp;#91;module$libs$greeting&amp;#93;
    :url #object&amp;#91;java.net.URL 0x4a067c25 file:/Users/marianeise/Documents/development/hello&amp;#95;world/out/greeting.js&amp;#93;
    :closure-lib true
    :lib-path out/greeting.js}
 module$libs$german
   {:requires &amp;#91;&amp;#93;
    :provides &amp;#91;module$libs$german&amp;#93;
    :url #object&amp;#91;java.net.URL 0xa1217f9 file:/Users/marianeise/Documents/development/hello&amp;#95;world/out/german.js&amp;#93;
    :closure-lib true
    :lib-path out/german.js}
...}
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;To learn more about the dependency index, have a look at &lt;a href='https://github.com/clojure/clojurescript/blob/master/src/main/clojure/cljs/js&amp;#95;deps.clj'&gt;js&amp;#95;deps.clj&lt;/a&gt; in the ClojureScript project. To see the current progress for this project, have a look at the GitHub &lt;a href='https://github.com/mneise/clojurescript/tree/CLJS-1092'&gt;branch&lt;/a&gt;.&lt;/p&gt;
</description>
<pubDate>
Mon, 08 Jun 2015 00:00:00 +0200
</pubDate>
<author>
Maria Neise
</author>
</item>
<item>
<guid>
http://mneise.github.io/posts/2015-06-02-week-1.html
</guid>
<link>
http://mneise.github.io/posts/2015-06-02-week-1.html
</link>
<title>
GSoC: Week 1
</title>
<description>
&lt;p&gt;&lt;em&gt;I have been accepted to this years Google's Summer of Code to work on ClojureScript. The goal of my project is to improve the integration of ClojureScript with the existing JavaScript ecosystem. I will post weekly updates about the progress of the project here. For more details about the project have a look at the ClojureScript GitHub &lt;a href='https://github.com/clojure/clojurescript/wiki/Google-Summer-of-Code-2015'&gt;wiki page&lt;/a&gt;.&lt;/em&gt;&lt;/p&gt;&lt;p&gt;Last week was the first week of my Google's Summer of Code project. The first part of the project that I will be working on is adding JavaScript module support to ClojureScript, meaning that CommonJS, AMD and ECMAScript 6 modules can be included into a ClojureScript project. For this, we will be using functionality that is already included in the Google Closure compiler. The Google Closure compiler has the classes &lt;code&gt;ProcessCommonJSModules&lt;/code&gt; and &lt;code&gt;ProcessEs6Modules&lt;/code&gt;, which each convert either a CommonJS or ECMAScript 6 module into a Google Closure module. To be able to use those two classes directly from within the ClojureScript compiler, we needed to make the classes and its constructors public. Luckily, our &lt;a href='https://github.com/google/closure-compiler/pull/952'&gt;pull request&lt;/a&gt; to the Google Closure compiler project got accepted and our changes should be included in the next release of the project. With those changes in place, I started off by working on including a CommonJS module into a ClojureScript project. Following, I will try to describe which functionality we will need to add to the ClojurScript compiler so that users can include a CommonJS module without modifying it.&lt;/p&gt;&lt;p&gt;Assume we have the following simple CommonJS module in &lt;code&gt;libs/greeting.js&lt;/code&gt;:&lt;/p&gt;&lt;pre&gt;&lt;code class=&quot;javascript&quot;&gt;exports.hello = function&amp;#40;name&amp;#41; {
    return &amp;quot;Hello, &amp;quot; + name;
};
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;We can include this module as a foreign library. To specify the module type, we will be adding a new compiler option called &lt;code&gt;module-type&lt;/code&gt;, which can have the values &lt;code&gt;:commonjs&lt;/code&gt;, &lt;code&gt;:es6&lt;/code&gt; and &lt;code&gt;:amd&lt;/code&gt;.&lt;/p&gt;&lt;pre&gt;&lt;code class=&quot;clojure&quot;&gt;&amp;#40;require 'cljs.build.api&amp;#41;

&amp;#40;cljs.build.api/build &amp;quot;src&amp;quot;
                      {:main 'hello-world.core
                       :output-to &amp;quot;out/main.js&amp;quot;
                       :foreign-libs &amp;#91;{:file &amp;quot;libs/greeting.js&amp;quot;
                                       :provides &amp;#91;&amp;quot;greeting&amp;quot;&amp;#93;
                                       :module-type :commonjs}&amp;#93;}&amp;#41;
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;To be able to use the functionality provided by the module, we need to require it into our namespace with the same name that we used in the &lt;code&gt;provides&lt;/code&gt; compiler option for the module.&lt;/p&gt;&lt;pre&gt;&lt;code class=&quot;clojure&quot;&gt;&amp;#40;ns hello-world.core
  &amp;#40;:require &amp;#91;greeting&amp;#93;&amp;#41;&amp;#41;

&amp;#40;enable-console-print!&amp;#41;

&amp;#40;println &amp;#40;.hello js/greeting &amp;quot;World!&amp;quot;&amp;#41;&amp;#41;
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;If the ClojureScript compiler would try to handle the module the same way as any other foreign library, we would get the following errors:&lt;/p&gt;&lt;p&gt;&lt;img src=&quot;/images/week1-error1.png&quot; alt=&quot;error 1&quot; /&gt;&lt;/p&gt;&lt;p&gt;We are getting the first error, because the Google Closure dependency management system doesn't implement the CommonJS specification. To get rid of the first error, we need to convert the CommonJS module into a form that is understood by the Google Closure dependency management system and can be used in combination with other Google Closure modules. For this task, we can use the &lt;code&gt;ProcessCommonJSModules&lt;/code&gt; class. Instead of wrapping everything in a function it adds a filename based prefix to the global variables and adds a &lt;code&gt;goog.provide&lt;/code&gt; statement.&lt;/p&gt;&lt;pre&gt;&lt;code class=&quot;javascript&quot;&gt;goog.provide&amp;#40;&amp;quot;module$libs$greeting&amp;quot;&amp;#41;;
var module$libs$greeting = {};
module$libs$greeting.hello = function&amp;#40;name&amp;#41; {
  return &amp;quot;Hello, &amp;quot; + name;
};
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;Converting the CommonJS module helps us to get rid of the &lt;code&gt;exports&lt;/code&gt; error, but we are still left with the &lt;code&gt;greeting is not defined&lt;/code&gt; error. If you have a look at the JavaScript that the compiler emitted, you can see that we are requiring the module as &lt;code&gt;greeting&lt;/code&gt; and later use the &lt;code&gt;greeting&lt;/code&gt; object to call the &lt;code&gt;hello&lt;/code&gt; function on.&lt;/p&gt;&lt;pre&gt;&lt;code class=&quot;javascript&quot;&gt;// Compiled by ClojureScript 0.0-0000 {}
goog.provide&amp;#40;'hello&amp;#95;world.core'&amp;#41;;
goog.require&amp;#40;'cljs.core'&amp;#41;;
goog.require&amp;#40;'greeting'&amp;#41;;
cljs.core.enable&amp;#95;console&amp;#95;print&amp;#95;BANG&amp;#95;.call&amp;#40;null&amp;#41;;
cljs.core.println.call&amp;#40;null,greeting.hello&amp;#40;&amp;quot;World!&amp;quot;&amp;#41;&amp;#41;;

//# sourceMappingURL=core.js.map
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;Looking at the rewritten module code we can see that we should be using &lt;code&gt;module$libs$greeting&lt;/code&gt; to refer to the module instead. This means, in the ClojureScript compiler whenever we see a reference to the module using the &quot;old&quot; name (&lt;code&gt;greeting&lt;/code&gt;) while emitting the JavaScript we need to replace it with the &quot;new&quot; name (&lt;code&gt;module$libs$greeting&lt;/code&gt;).&lt;/p&gt;&lt;pre&gt;&lt;code class=&quot;javascript&quot;&gt;// Compiled by ClojureScript 0.0-0000 {}
goog.provide&amp;#40;'hello&amp;#95;world.core'&amp;#41;;
goog.require&amp;#40;'cljs.core'&amp;#41;;
goog.require&amp;#40;'module$libs$greeting'&amp;#41;;
cljs.core.enable&amp;#95;console&amp;#95;print&amp;#95;BANG&amp;#95;.call&amp;#40;null&amp;#41;;
cljs.core.println.call&amp;#40;null,module$libs$greeting.hello&amp;#40;&amp;quot;World!&amp;quot;&amp;#41;&amp;#41;;

//# sourceMappingURL=core.js.map
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;Finally, we get our &lt;code&gt;Hello, World!&lt;/code&gt;.&lt;/p&gt;&lt;p&gt;&lt;img src=&quot;/images/week1-hello.png&quot; alt=&quot;Hello, World!&quot; /&gt;&lt;/p&gt;&lt;p&gt;To see the current progress, have a look at the GitHub &lt;a href='https://github.com/mneise/clojurescript/tree/CLJS-1092'&gt;branch&lt;/a&gt;.&lt;/p&gt;
</description>
<pubDate>
Tue, 02 Jun 2015 00:00:00 +0200
</pubDate>
<author>
Maria Neise
</author>
</item>
</channel>
</rss>
